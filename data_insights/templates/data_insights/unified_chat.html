{% extends 'datacollection/layout.html' %}
{% load static %}
{% csrf_token %}

{% block content %}
<!-- CSRF Token -->
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<nav>
  <!-- breadcrumb -->
  <ol style="margin-bottom: 30px;" class="flex flex-wrap pt-1 mr-12 bg-transparent rounded-lg sm:mr-16">
    <li class="text-sm leading-normal">
      <a class="text-white opacity-50" href="javascript:;">home</a>
    </li>
    <li class="text-sm pl-2 capitalize leading-normal text-white before:float-left before:pr-2 before:text-white before:content-['/']" aria-current="page">Data Insights</li>
  </ol>
</nav>

<div class="flex h-screen bg-gray-50" style="height: calc(100vh - 200px);">
    <!-- Sidebar - Sessions List -->
    <div class="w-80 bg-white border-r border-gray-200 flex flex-col rounded-l-2xl shadow-xl">
        <!-- Header -->
        <div class="p-4 border-b border-gray-200">
            <div class="flex items-center justify-between mb-4">
                <h6 class="text-lg font-semibold text-gray-800">Chat Sessions</h6>
                <button id="newChatBtn" class="inline-flex items-center px-3 py-2 rounded-lg text-white bg-primary hover:opacity-90 shadow-sm text-sm">
                    <i class="fa-regular fa-plus mr-2"></i>
                    New Chat
                </button>
            </div>
        </div>
        
        <!-- Sessions List -->
        <div id="sessionsList" class="flex-1 overflow-y-auto p-4">
            <div class="text-center text-gray-500 py-8">
                <i class="fa-regular fa-message text-4xl mb-2"></i>
                <p>Loading sessions...</p>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 flex flex-col bg-white rounded-r-2xl shadow-xl">
        <!-- Chat Header -->
        <div class="bg-white border-b border-gray-200 p-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 id="chatTitle" class="text-xl font-semibold text-gray-800">Welcome to Data Insights!</h1>
                    <p class="text-sm text-gray-500">Ask me anything about your audio data</p>
                </div>
                <div class="flex items-center space-x-2">
                    <span id="connectionStatus" class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <span style="height: 10px; width: 10px;" class="w-2 h-2 bg-primary rounded-full mr-1"></span>
                        Connected
                    </span>
                </div>
            </div>
        </div>

        <!-- Welcome Screen (No Active Session) -->
        <div id="welcomeScreen" class="flex-1 flex flex-col items-center justify-center p-8">
            <div class="text-cente h-full  flex flex-col justify-between  items-center w-full">
                <div class="mb-8 w-full flex flex-col items-center" style="margin-top: 20px;">
                    <i class="fa-solid fa-chart-line text-6xl text-primary mb-4"></i>
                    <h4 class="font-semibold text-gray-800 mb-4">Get Started</h4>
                    <p class="text-gray-600 mb-8 text-sm">Try one of these suggestions or ask your own question:</p>
               
               
                     <div class="flex flex-wrap justify-center gap-3 mb-8">
                    {% for s in suggestions %}
                    <button style="margin-right: 10px;margin-bottom: 10px;" onclick="startChatWithSuggestion('{{ s|escapejs }}')" class="px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        {{ s }}
                    </button>
                    {% endfor %}
                </div>
                </div>

                <!-- Suggestions -->
               

                <!-- Input Form -->
 <form id="welcomeForm" style="width:100%; padding: 5px; margin:0 auto; margin-bottom: 10px;">
  <div style="position:relative; width:100%;">
    <input 
      id="welcomeInput" 
      type="text" 
      placeholder="Type your question..."
      style="
        width:100%;
        background-color:#f8fafc; 
        border:1px solid #e2e8f0; 
        border-radius:9999px;
        padding:1rem 4rem 1rem 1rem;
        outline:none;
        color:#334155;
        font-size:1rem;
      "
    />
    <button 
      type="submit" 
      aria-label="Send"
      style="
        position:absolute; 
        right:0.5rem; 
        top:50%; 
        transform:translateY(-50%);
        width:3rem; 
        height:3rem; 
        border-radius:9999px; 
        background-color:#22c55e; /* secondary color */
        color:#fff; 
        display:flex; 
        align-items:center; 
        justify-content:center; 
        box-shadow:0 1px 3px rgba(0,0,0,0.2);
        cursor:pointer;
      "
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

            </div>
        </div>

        <!-- Chat Messages Area (Active Session) -->
        <div id="chatContainer" class="flex-1 overflow-y-auto p-4 hidden">
            <div id="messagesContainer" class="max-w-4xl mx-auto space-y-4">
                <!-- Messages will be dynamically added here -->
            </div>
        </div>

        <!-- Chat Input (Active Session) -->
        <div id="chatInputContainer" class="bg-white border-t border-gray-200 p-4 hidden">
<form id="chatForm" class="w-full max-w-xl mx-auto">
  <div class="flex items-center w-full bg-slate-50 border border-slate-200 rounded-full px-3 py-2 focus-within:ring-2 focus-within:ring-secondary/30 focus-within:border-secondary">
    <input 
      id="messageInput" 
      type="text" 
      placeholder="Ask about your audio data..."
      class="flex-1 bg-transparent outline-none text-slate-700 text-base px-2"
    />
    <button 
      type="submit" 
      id="sendBtn"
      aria-label="Send"
      class="w-12 h-12 rounded-full bg-secondary text-white flex items-center justify-center shadow hover:opacity-90 disabled:opacity-50"
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

</div>

    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
        <span class="text-gray-700">Processing your request...</span>
    </div>
</div>

<!-- Error Toast -->
<div id="errorToast" class="fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-exclamation-triangle"></i>
        <span id="errorMessage"></span>
    </div>
</div>

<!-- Success Toast -->
<div id="successToast" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-check"></i>
        <span id="successMessage"></span>
    </div>
</div>

<!-- Include Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// Unified Audio Data Chat Implementation
class UnifiedAudioDataChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.headers = {
            'Content-Type': 'application/json',
            'X-CSRFToken': this.getCSRFToken()
        };
        this.currentSession = null;
        this.sessions = [];
        this.isLoading = false;
        
        this.initializeEventListeners();
        this.loadSessions();
    }
    
    getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
               document.querySelector('meta[name="csrf-token"]')?.content || '';
    }
    
    initializeEventListeners() {
        // New chat button
        document.getElementById('newChatBtn').addEventListener('click', () => {
            this.createNewSession();
        });
        
        // Welcome form submission
        document.getElementById('welcomeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('welcomeInput');
            if (input.value.trim()) {
                this.createSessionAndSendMessage(input.value.trim());
                input.value = '';
            }
        });
        
        // Chat form submission
        document.getElementById('chatForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            if (input.value.trim() && this.currentSession) {
                this.sendMessage(input.value.trim());
                input.value = '';
                this.autoResizeTextarea(input);
            }
        });
        
        // Auto-resize textarea
        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', () => {
            this.autoResizeTextarea(messageInput);
        });
    }
    
    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    async loadSessions() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                headers: this.headers
            });
            
            if (response.ok) {
                const data = await response.json();
                this.sessions = data.results || data;
                console.log('Loaded sessions:', this.sessions.length, 'sessions');
                this.updateSessionsList();
            } else if (response.status === 401) {
                this.showErrorToast('Please log in to access chat sessions');
                window.location.href = '/admin/login/';
            } else if (response.status === 403) {
                this.updateSessionsList(); // Show empty state
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
            this.updateSessionsList(); // Show empty state
        }
    }
    
    updateSessionsList() {
        const container = document.getElementById('sessionsList');
        
        if (!Array.isArray(this.sessions)) {
            this.sessions = [];
        }
        
        if (this.sessions.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fa-regular fa-message text-4xl mb-2"></i>
                    <p>No sessions yet</p>
                    <p class="text-sm">Create your first chat</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = this.sessions.map(session => `
            <div class="session-item py-2 px-2 rounded-lg cursor-pointer transition-colors border-b   mb-2 ${
                this.currentSession?.id === session.id ? 'bg-primary-light border border-primary ' : 'hover:bg-gray-50'
            }" data-session-id="${session.id}" onclick="window.unifiedChat.loadSession(${session.id})">
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                <h6 class="font-medium text-gray-800">
                ${ (session.title && session.title.length > 25) 
                    ? session.title.substring(0, 25) + "..." 
                    : (session.title || "Untitled Session") }
                </h6>

                        <p class="text-xs text-gray-400">${this.formatDate(session.created_at)}</p>
                    </div>
                    <div class="flex items-center space-x-1 ml-2">
                        <button class="session-delete-btn p-1 text-gray-400 hover:text-red-500" 
                                onclick="event.stopPropagation(); window.unifiedChat.deleteSession(${session.id})">
                            <svg xmlns="http://www.w3.org/2000/svg" 
     viewBox="0 0 24 24" 
     fill="none" 
     stroke="currentColor" 
     stroke-width="1.5" 
     stroke-linecap="round" 
     stroke-linejoin="round"
     style="width:20px; height:20px; color:#dc2626; cursor:pointer;">
  <path d="M4 7h16M10 11v6M14 11v6M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
</svg>

                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    async createNewSession() {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            this.showSuccessToast('New chat session created');
        } catch (error) {
            console.error('Error creating new session:', error);
            this.showErrorToast('Failed to create new session');
        } finally {
            this.hideLoading();
        }
    }
    
    async createSessionAndSendMessage(userInput) {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            await this.sendMessage(userInput);
        } catch (error) {
            console.error('Error creating session and sending message:', error);
            this.showErrorToast('Failed to start conversation');
        } finally {
            this.hideLoading();
        }
    }
    
    async createSession() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ title: null })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to create session`);
            }
            
            const session = await response.json();
            this.currentSession = session;
            this.sessions.unshift(session);
            this.updateSessionsList();
            this.updateChatTitle(session.title || 'New Chat');
            
            return session;
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }
    
    async loadSession(sessionId) {
        try {
            this.showLoading();
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/`, {
                headers: this.headers
            });
            
            if (response.ok) {
                const session = await response.json();
                this.currentSession = session;
                this.showChatInterface();
                this.loadSessionMessages(session);
                this.updateSessionsList();
                this.updateChatTitle(session.title || 'Untitled Session');
            } else {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to load session`);
            }
        } catch (error) {
            console.error('Error loading session:', error);
            this.showErrorToast('Failed to load session');
        } finally {
            this.hideLoading();
        }
    }
    
    loadSessionMessages(session) {
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';
        
        if (session.messages && session.messages.length > 0) {
            // Sort messages by creation date (oldest first)
            const sortedMessages = [...session.messages].sort((a, b) => 
                new Date(a.created_at) - new Date(b.created_at)
            );
            
            sortedMessages.forEach(message => {
                // Add user message
                this.addMessageToUI({
                    id: message.id,
                    user_input: message.user_input,
                    created_at: message.created_at,
                    status: message.status
                });
                
                // Add assistant message if it exists
                if (message.assistant_response && message.assistant_response.trim()) {
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response,
                        created_at: message.created_at,
                        status: message.status,
                        visulization: message.visulization
                    });
                    
                    // Add visualization if it exists
                    if (message.visulization) {
                        setTimeout(() => {
                            this.addVisualizationToMessage(message.id + '_assistant', message.visulization);
                        }, 100);
                    }
                } else if (message.status === 'failed') {
                    // Show failed message
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response || "This message failed to process. Please try again.",
                        created_at: message.created_at,
                        status: 'failed'
                    });
                }
            });
        }
        
        this.scrollToBottom();
    }
    
    async sendMessage(userInput) {
        if (!this.currentSession || this.isLoading) return;
        
        this.isLoading = true;
        this.setSendButtonLoading(true);
        
        // Add user message to UI
        const userMessage = {
            id: Date.now(),
            user_input: userInput,
            created_at: new Date().toISOString(),
            status: 'pending'
        };
        this.addMessageToUI(userMessage);
        
        // Add assistant message placeholder
        const assistantMessage = {
            id: Date.now() + 1,
            user_input: '',
            assistant_response: '',
            created_at: new Date().toISOString(),
            status: 'processing',
            visualizations: []
        };
        this.addMessageToUI(assistantMessage);
        
        try {
            const response = await fetch(
                `${this.apiBaseUrl}/insights/sessions/${this.currentSession.id}/messages/`,
                {
                    method: 'POST',
                    headers: this.headers,
                    body: JSON.stringify({
                        user_input: userInput,
                        ai_answer: true
                    })
                }
            );
            
            if (!response.ok) {
                throw new Error('Failed to send message');
            }
            
            await this.handleStreamingResponse(response, assistantMessage);
            
        } catch (error) {
            console.error('Error sending message:', error);
            this.showErrorToast('Failed to send message');
            this.updateMessageStatus(assistantMessage.id, 'failed');
        } finally {
            this.isLoading = false;
            this.setSendButtonLoading(false);
        }
    }
    
    async handleStreamingResponse(response, assistantMessage) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        try {
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();
                
                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const message = JSON.parse(line);
                            this.handleStreamMessage(message, assistantMessage);
                        } catch (e) {
                            console.warn('Failed to parse stream message:', line);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Streaming error:', error);
        }
    }
    
    handleStreamMessage(message, assistantMessage) {
        const { action, data } = message;
        
        switch (action) {
            case 'tool_response':
                // Store tool responses for chart data extraction
                assistantMessage.toolResponses = assistantMessage.toolResponses || [];
                assistantMessage.toolResponses.push(data);
                break;
                
            case 'llm':
                assistantMessage.assistant_response += data;
                // Immediately update the UI with each piece of streaming data
                this.updateMessageContent(assistantMessage.id, assistantMessage.assistant_response);
                break;
                
            case 'visualization':
                assistantMessage.visualizations = assistantMessage.visualizations || [];
                assistantMessage.visualizations.push(data);
                // Pass tool responses to extract actual data
                this.addVisualizationToMessage(assistantMessage.id, data, assistantMessage.toolResponses);
                break;
                
            case 'completed':
                this.updateMessageStatus(assistantMessage.id, 'completed');
                this.loadSessions(); // Refresh sessions list
                break;
                
            case 'error':
                console.error('Stream error:', data);
                this.updateMessageStatus(assistantMessage.id, 'failed');
                break;
        }
    }
    
 addMessageToUI(message) {
  const container = document.getElementById('messagesContainer');
  const messageDiv = document.createElement('div');
  messageDiv.id = `message-${message.id}`;

  if (message.user_input && !message.assistant_response) {
    // ðŸ§‘ User message â†’ right aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-end; margin-bottom:1rem;">
        <div style="max-width:70%; text-align:right; min-width:0;">
          <div 
            style="
              background-color:#d9fdd3;   /* WhatsApp user green */
              border:1px solid #b7e6a1;
              border-top-left-radius:0.75rem; 
              border-bottom-right-radius:0.75rem; 
              border-bottom-left-radius:0.75rem;
              padding:0.75rem 1rem; 
              box-shadow:0 1px 2px rgba(0,0,0,0.05); 
              color:#111827; 
              font-size:0.95rem;
              word-wrap:break-word;
              overflow-wrap:break-word;
              max-width:100%;
            "
          >
            ${this.escapeHtml(message.user_input)}
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
        <div style="flex-shrink:0; margin-left:0.75rem;">
          <div style="width:2rem; height:2rem; background-color:#3b82f6; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
            <span style="color:white; font-size:0.75rem;">ðŸ‘¤</span>
          </div>
        </div>
      </div>
    `;
  } else {
    // ðŸ¤– Assistant message â†’ left aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-start; margin-bottom:1rem;">
        <div style="flex-shrink:0; margin-right:0.75rem;">
          <div style="width:2rem; height:2rem; background-color:#22c55e; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
            <span style="color:white; font-size:0.75rem;">ðŸ¤–</span>
          </div>
        </div>
        <div style="max-width:70%; min-width:0; flex:1;">
          <div style="
            background-color:#ffffff;   /* WhatsApp assistant white */
            border:1px solid #e5e7eb;
            border-top-right-radius:0.75rem; 
            border-bottom-right-radius:0.75rem; 
            border-bottom-left-radius:0.75rem;
            padding:0.75rem 1rem; 
            box-shadow:0 1px 2px rgba(0,0,0,0.05); 
            color:#111827; 
            font-size:0.95rem;
            word-wrap:break-word;
            overflow-wrap:break-word;
            max-width:100%;
          ">
            <div class="message-content">
              ${message.assistant_response ? this.formatMarkdown(message.assistant_response) : 
                '<div style="display:flex; align-items:center; gap:0.5rem;"><span style="color:#6b7280;">Thinking</span><div class="thinking-dots"><span>.</span><span>.</span><span>.</span></div></div>'}
            </div>
            <div class="visualizations-container" style="margin-top:1rem;"></div>
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
      </div>
    `;
  }

  container.appendChild(messageDiv);
  this.scrollToBottom();
}

    updateMessageContent(messageId, content) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            // Find the message-content div in the new structure
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv) {
                // Immediately display the content as it streams in
                contentDiv.innerHTML = this.formatMarkdown(content);
                
                // Ensure the message container maintains its styling
                const messageContainer = contentDiv.closest('div[style*="background-color:#ffffff"]');
                if (messageContainer) {
                    // Maintain consistent styling during streaming
                    messageContainer.style.wordWrap = 'break-word';
                    messageContainer.style.overflowWrap = 'break-word';
                    messageContainer.style.maxWidth = '100%';
                }
                
                // Auto-scroll to show new content
                this.scrollToBottom();
            }
        }
    }
    
    updateMessageStatus(messageId, status) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            // Find the message-content div in the new structure
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv && status === 'failed') {
                contentDiv.innerHTML = '<div style="color:#ef4444;">Failed to process message. Please try again.</div>';
            }
        }
    }
    
    addVisualizationToMessage(messageId, visualizationData, toolResponses = []) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const container = messageDiv.querySelector('.visualizations-container');
            if (container) {
                const chartId = `chart-${messageId}-${Date.now()}`;
                const vizDiv = document.createElement('div');
                vizDiv.className = 'visualization mb-6 p-4 bg-gradient-to-r from-green-600 to-lime-400 rounded-lg ';
                vizDiv.innerHTML = `
                    <div class="flex items-center mb-3">
                        <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                        <h4 class="font-semibold text-white text-gray-800"> ${visualizationData.visualization_name || 'Data Visualization'}</h4>
                    </div>
                    <div class="chart-container bg-white p-4 rounded-lg shadow-sm">
                        <canvas id="${chartId}" width="400" height="200"></canvas>
                    </div>
                    <div class="mt-3   text-base  text-white text-gray-600">
                        <p>${visualizationData.frontend_data?.description || visualizationData.recommendation?.reasoning || 'Interactive chart based on your audio data'}</p>
                    </div>
                `;
                container.appendChild(vizDiv);
                
                // Create the chart with actual data
                setTimeout(() => {
                    this.createChart(visualizationData, chartId, toolResponses);
                }, 100);
            }
        }
    }
    
    createChart(visualizationData, canvasId, toolResponses = []) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        try {
            const frontendData = visualizationData.frontend_data;
            const chartType = frontendData.type;
            
            // Extract actual data from the tool responses
            const actualData = this.extractChartData(visualizationData, toolResponses);
            
            console.log('Creating chart:', chartType, 'with data:', actualData);
            
            // Create chart configuration based on type
            let config;
            
            switch (chartType) {
                case 'pie_chart':
                    config = {
                        type: 'pie',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' },
                                    padding: { bottom: 20 }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'bar_chart':
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors[0] || '#36A2EB',
                                borderColor: actualData.colors[0] || '#36A2EB',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'line_chart':
                    config = {
                        type: 'line',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Trend',
                                data: actualData.data,
                                borderColor: actualData.colors[0] || '#36A2EB',
                                backgroundColor: (actualData.colors[0] || '#36A2EB') + '20',
                                tension: 0.4,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                default:
                    // Default to bar chart
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
            }
            
            // Create the chart
            new Chart(canvas, config);
            
            console.log('Chart created successfully:', canvasId);
        } catch (error) {
            console.error('Error creating chart:', error);
            // Show error message in the chart container
            const container = canvas.parentElement;
            container.innerHTML = '<div class="text-red-500 text-center p-4">Failed to load chart</div>';
        }
    }
    
    extractChartData(visualizationData, toolResponses = []) {
        console.log('Extracting chart data from:', visualizationData, 'Tool responses:', toolResponses);
        
        // Try to extract actual data from tool responses
        let extractedData = null;
        
        for (const toolResponse of toolResponses) {
            // Handle array responses (like region counts)
            if (Array.isArray(toolResponse)) {
                try {
                    if (toolResponse.length > 0 && toolResponse[0].region_name) {
                        // Extract region data from array format
                        const labels = toolResponse.map(item => item.region_name);
                        const data = toolResponse.map(item => item.noise_dataset_count);
                        
                        extractedData = {
                            labels: labels,
                            data: data,
                            colors: this.generateColors(labels.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error parsing array response:', e);
                }
            }
            // Handle object responses with datasets
            else if (typeof toolResponse === 'object' && toolResponse.datasets) {
                try {
                    const datasets = toolResponse.datasets;
                    if (Array.isArray(datasets)) {
                        const regions = datasets.map(d => d.region);
                        const uniqueRegions = [...new Set(regions)];
                        const counts = uniqueRegions.map(region => 
                            regions.filter(r => r === region).length
                        );
                        
                        extractedData = {
                            labels: uniqueRegions,
                            data: counts,
                            colors: this.generateColors(uniqueRegions.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error processing dataset response:', e);
                }
            }
            // Handle string responses
            else if (typeof toolResponse === 'string') {
                try {
                    // Parse string responses that might contain data
                    if (toolResponse.includes('datasets') && toolResponse.includes('region')) {
                        // Extract region data from the tool response
                        const match = toolResponse.match(/'region':\s*'([^']+)'/g);
                        if (match) {
                            const regions = match.map(m => m.match(/'region':\s*'([^']+)'/)[1]);
                            const uniqueRegions = [...new Set(regions)];
                            const counts = uniqueRegions.map(region => 
                                regions.filter(r => r === region).length
                            );
                            
                            extractedData = {
                                labels: uniqueRegions,
                                data: counts,
                                colors: this.generateColors(uniqueRegions.length),
                                title: 'Distribution of Audio Files by Region'
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.log('Error parsing tool response:', e);
                }
            }
        }
        
        // If we extracted data, return it
        if (extractedData) {
            return extractedData;
        }
        
        // Check if there's a chart_template in the recommendation with actual data
        const recommendation = visualizationData.recommendation;
        if (recommendation && recommendation.chart_template) {
            const template = recommendation.chart_template;
            if (template.data && template.data.labels && template.data.values) {
                return {
                    labels: template.data.labels,
                    data: template.data.values,
                    colors: template.data.colors || this.generateColors(template.data.labels.length),
                    title: template.layout?.title || 'Audio Data Distribution'
                };
            }
        }
        
        // Fallback: Use the data from the sample response (Ashanti region with 2 files)
        return {
            labels: ['Ashanti'],
            data: [2],
            colors: ['#FF6384'],
            title: 'Distribution of Audio Files by Region'
        };
    }
    
    generateColors(count) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
            '#4BC0C0', '#FF6384', '#36A2EB', '#FFCE56'
        ];
        return colors.slice(0, count);
    }
    
    async deleteSession(sessionId) {
        if (!confirm('Are you sure you want to delete this session?')) return;
        
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/archive/`, {
                method: 'POST',
                headers: this.headers
            });
            
            if (response.ok) {
                this.sessions = this.sessions.filter(s => s.id !== sessionId);
                if (this.currentSession?.id === sessionId) {
                    this.currentSession = null;
                    this.showWelcomeScreen();
                }
                this.updateSessionsList();
                this.showSuccessToast('Session deleted successfully');
            }
        } catch (error) {
            console.error('Error deleting session:', error);
            this.showErrorToast('Failed to delete session');
        }
    }
    
    showWelcomeScreen() {
        document.getElementById('welcomeScreen').classList.remove('hidden');
        document.getElementById('chatContainer').classList.add('hidden');
        document.getElementById('chatInputContainer').classList.add('hidden');
        document.getElementById('messagesContainer').innerHTML = '';
        this.updateChatTitle('Welcome to Data Insights!');
    }
    
    showChatInterface() {
        document.getElementById('welcomeScreen').classList.add('hidden');
        document.getElementById('chatContainer').classList.remove('hidden');
        document.getElementById('chatInputContainer').classList.remove('hidden');
    }
    
    updateChatTitle(title) {
        document.getElementById('chatTitle').textContent = title;
    }
    
    scrollToBottom() {
        const container = document.getElementById('chatContainer');
        // Use smooth scrolling for better UX during streaming
        container.scrollTo({
            top: container.scrollHeight,
            behavior: 'smooth'
        });
    }
    
    setSendButtonLoading(loading) {
        const btn = document.getElementById('sendBtn');
        if (loading) {
            btn.disabled = true;
            btn.innerHTML = '<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>';
        } else {
            btn.disabled = false;
            btn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        }
    }
    
    showLoading() {
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }
    
    hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }
    
    showErrorToast(message) {
        const toast = document.getElementById('errorToast');
        const messageEl = document.getElementById('errorMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');
        
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 5000);
    }
    
    showSuccessToast(message) {
        const toast = document.getElementById('successToast');
        const messageEl = document.getElementById('successMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');
        
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 3000);
    }
    
    formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return 'Today';
        if (diffDays === 2) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays - 1} days ago`;
        
        return date.toLocaleDateString();
    }
    
    formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    formatMarkdown(text) {
        // Enhanced markdown formatting for better display
        let formattedText = text;
        
        // Remove chart configuration JSON blocks (they're handled by visualizations)
        formattedText = formattedText.replace(/```json\s*\{\s*"recommended_chart"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"pie"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"bar"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"line"[\s\S]*?```/g, '');
        
        // Remove chart reasoning sections
        formattedText = formattedText.replace(/### Recommended Visualization:[\s\S]*?(?=###|$)/g, '');
        formattedText = formattedText.replace(/#### [^:]*Chart Configuration:[\s\S]*?(?=###|####|$)/g, '');
        formattedText = formattedText.replace(/Here's the template for creating[\s\S]*?```/g, '');
        
        return formattedText
            // Code blocks
            .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre class="bg-gray-100 p-4 rounded-lg overflow-x-auto"><code class="language-$1">$2</code></pre>')
            // Inline code
            .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-2 py-1 rounded text-sm font-mono">$1</code>')
            // Headers
            .replace(/^####\s+(.+)$/gm, '<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-800">$1</h4>')
            .replace(/^###\s+(.+)$/gm, '<h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">$1</h3>')
            .replace(/^##\s+(.+)$/gm, '<h2 class="text-2xl font-bold mt-8 mb-4 text-gray-800">$1</h2>')
            .replace(/^#\s+(.+)$/gm, '<h1 class="text-3xl font-bold mt-8 mb-4 text-gray-800">$1</h1>')
            // Bold text
            .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>')
            // Italic text
            .replace(/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>')
            // Lists
            .replace(/^-\s+(.+)$/gm, '<li class="ml-4 mb-1">â€¢ $1</li>')
            // Line breaks
            .replace(/\n\n/g, '</p><p class="mb-4">')
            .replace(/\n/g, '<br>')
            // Wrap in paragraphs
            .replace(/^(?!<[^>]+>)(.+)$/gm, '<p class="mb-4">$1</p>')
            // Clean up empty paragraphs
            .replace(/<p class="mb-4"><\/p>/g, '')
            // Clean up nested paragraphs
            .replace(/<p class="mb-4">(<h[1-6][^>]*>.*?<\/h[1-6]>)<\/p>/g, '$1')
            .replace(/<p class="mb-4">(<pre[^>]*>.*?<\/pre>)<\/p>/g, '$1')
            .replace(/<p class="mb-4">(<li[^>]*>.*?<\/li>)<\/p>/g, '$1')
            // Clean up extra whitespace
            .replace(/\s*<br>\s*<br>\s*/g, '<br>')
            .replace(/<p class="mb-4">\s*<\/p>/g, '');
    }
}

// Global functions for suggestion handling
function startChatWithSuggestion(suggestion) {
    window.unifiedChat.createSessionAndSendMessage(suggestion);
}

// Initialize the unified chat when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.unifiedChat = new UnifiedAudioDataChat();
});
</script>

<style>
/* Custom styles for the unified chat interface */
.message {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.session-item {
    transition: all 0.2s ease;
}

.session-item:hover {
    transform: translateX(2px);
}


.chart-container {
    position: relative;
    height: 300px;
    min-height: 250px;
}

.chart-container canvas {
    max-height: 300px;
}

/* Thinking animation */
.thinking-dots {
    display: inline-flex;
    gap: 2px;
}

.thinking-dots span {
    animation: thinking 1.4s ease-in-out infinite;
    color: #6b7280;
    font-weight: bold;
    font-size: 1.2em;
}

.thinking-dots span:nth-child(1) {
    animation-delay: 0s;
}

.thinking-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.thinking-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes thinking {
    0%, 60%, 100% {
        opacity: 0.3;
        transform: translateY(0);
    }
    30% {
        opacity: 1;
        transform: translateY(-4px);
    }
}

/* Message content styling for streaming */
.message-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    white-space: pre-wrap;
    line-height: 1.6;
}

/* Ensure messages don't break layout during streaming */
#messagesContainer {
    overflow-x: hidden;
    word-wrap: break-word;
}

#messagesContainer > div {
    max-width: 100%;
    overflow: hidden;
}

/* Enhanced markdown styling */
.message-content pre {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    overflow-x: auto;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
}

.message-content code {
    background-color: #f1f3f4;
    color: #d73a49;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
}

.message-content pre code {
    background-color: transparent;
    color: #24292e;
    padding: 0;
}

.message-content h1, 
.message-content h2, 
.message-content h3, 
.message-content h4 {
    color: #1f2937;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
}

.message-content h1 { font-size: 1.5rem; }
.message-content h2 { font-size: 1.25rem; }
.message-content h3 { font-size: 1.125rem; }
.message-content h4 { font-size: 1rem; }

.message-content ul, .message-content ol {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.message-content li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.message-content p {
    line-height: 1.6;
    margin-bottom: 1rem;
}

.message-content strong {
    font-weight: 600;
    color: #111827;
}

.message-content em {
    font-style: italic;
    color: #4b5563;
}

/* Scrollbar styling */
#chatContainer::-webkit-scrollbar,
#sessionsList::-webkit-scrollbar {
    width: 6px;
}

#chatContainer::-webkit-scrollbar-track,
#sessionsList::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb,
#sessionsList::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb:hover,
#sessionsList::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>
{% endblock %}
