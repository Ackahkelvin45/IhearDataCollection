{% extends 'datacollection/layout.html' %}
{% load static %}
{% csrf_token %}

{% block content %}
<!-- CSRF Token -->
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<nav>
  <!-- breadcrumb -->
  <ol style="margin-bottom: 30px;" class="flex flex-wrap pt-1 mr-12 bg-transparent rounded-lg sm:mr-16">
    <li class="text-sm leading-normal">
      <a class="text-white opacity-50" href="javascript:;">home</a>
    </li>
    <li class="text-sm pl-2 capitalize leading-normal text-white before:float-left before:pr-2 before:text-white before:content-['/']" aria-current="page">Data Insights</li>
  </ol>
</nav>

<div class="flex h-screen bg-gray-50" style="height: calc(100vh - 200px);">
    <!-- Sidebar - Sessions List -->
    <div class="w-80 bg-white border-r border-gray-200 flex flex-col rounded-l-2xl shadow-xl">
        <!-- Header -->
        <div class="p-4 border-b border-gray-200">
            <div class="flex items-center justify-between mb-4">
                <h6 class="text-lg font-semibold text-gray-800">Chat Sessions</h6>
                <button id="newChatBtn" class="inline-flex items-center px-3 py-2 rounded-lg text-white bg-primary hover:opacity-90 shadow-sm text-sm">
                    <i class="fa-regular fa-plus mr-2"></i>
                    New Chat
                </button>
            </div>
        </div>

        <!-- Sessions List -->
        <div id="sessionsList" class="flex-1 overflow-y-auto p-4">
            <div class="text-center text-gray-500 py-8">
                <i class="fa-regular fa-message text-4xl mb-2"></i>
                <p>Loading sessions...</p>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 flex flex-col bg-white rounded-r-2xl shadow-xl">
        <!-- Chat Header -->
        <div class="bg-white border-b border-gray-200 p-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 id="chatTitle" class="text-xl font-semibold text-gray-800">Welcome to Data Insights!</h1>
                    <p class="text-sm text-gray-500">Ask me anything about your audio data</p>
                </div>
                <div class="flex items-center space-x-2">
                    <span id="connectionStatus" class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <span style="height: 10px; width: 10px;" class="w-2 h-2 bg-primary rounded-full mr-1"></span>
                        Connected
                    </span>
                </div>
            </div>
        </div>

        <!-- Welcome Screen (No Active Session) -->
        <div id="welcomeScreen" class="flex-1 flex flex-col items-center justify-center p-8">
            <div class="text-cente h-full  flex flex-col justify-between  items-center w-full">
                <div class="mb-8 w-full flex flex-col items-center" style="margin-top: 20px;">
                    <i class="fa-solid fa-chart-line text-6xl text-primary mb-4"></i>
                    <h4 class="font-semibold text-gray-800 mb-4">Get Started</h4>
                    <p class="text-gray-600 mb-8 text-sm">Try one of these suggestions or ask your own question:</p>


                     <div class="flex flex-wrap justify-center gap-3 mb-8">
                    {% for s in suggestions %}
                    <button style="margin-right: 10px;margin-bottom: 10px;" onclick="startChatWithSuggestion('{{ s|escapejs }}')" class="px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        {{ s }}
                    </button>
                    {% endfor %}
                </div>
                </div>

                <!-- Suggestions -->


                <!-- Input Form -->
 <form id="welcomeForm" style="width:100%; padding: 5px; margin:0 auto; margin-bottom: 10px;">
  <div style="position:relative; width:100%;">
    <input
      id="welcomeInput"
      type="text"
      placeholder="Type your question..."
      style="
        width:100%;
        background-color:#f8fafc;
        border:1px solid #e2e8f0;
        border-radius:9999px;
        padding:1rem 4rem 1rem 1rem;
        outline:none;
        color:#334155;
        font-size:1rem;
      "
    />
    <button
      type="submit"
      aria-label="Send"
      style="
        position:absolute;
        right:0.5rem;
        top:50%;
        transform:translateY(-50%);
        width:3rem;
        height:3rem;
        border-radius:9999px;
        background-color:#22c55e; /* secondary color */
        color:#fff;
        display:flex;
        align-items:center;
        justify-content:center;
        box-shadow:0 1px 3px rgba(0,0,0,0.2);
        cursor:pointer;
      "
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

            </div>
        </div>

        <!-- Chat Messages Area (Active Session) -->
        <div id="chatContainer" class="flex-1 overflow-y-auto p-4 hidden">
            <div id="messagesContainer" class="max-w-4xl mx-auto space-y-4">
                <!-- Messages will be dynamically added here -->
            </div>
        </div>

        <!-- Chat Input (Active Session) -->
        <div id="chatInputContainer" class="bg-white border-t border-gray-200 p-4 hidden">
<form id="chatForm" class="w-full max-w-xl mx-auto">
  <div class="flex items-center w-full bg-slate-50 border border-slate-200 rounded-full px-3 py-2 focus-within:ring-2 focus-within:ring-secondary/30 focus-within:border-secondary">
    <input
      id="messageInput"
      type="text"
      placeholder="Ask about your audio data..."
      class="flex-1 bg-transparent outline-none text-slate-700 text-base px-2"
    />
    <button
      type="submit"
      id="sendBtn"
      aria-label="Send"
      class="w-12 h-12 rounded-full bg-secondary text-white flex items-center justify-center shadow hover:opacity-90 disabled:opacity-50"
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

</div>

    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
        <span class="text-gray-700">Processing your request...</span>
    </div>
</div>

<!-- Error Toast -->
<div id="errorToast" class="fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-exclamation-triangle"></i>
        <span id="errorMessage"></span>
    </div>
</div>

<!-- Success Toast -->
<div id="successToast" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-check"></i>
        <span id="successMessage"></span>
    </div>
</div>

<!-- Include Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Include Marked.js for proper markdown rendering -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<!-- Include DOMPurify for security -->
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>

<script>
// Unified Audio Data Chat Implementation
class UnifiedAudioDataChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.headers = {
            'Content-Type': 'application/json',
            'X-CSRFToken': this.getCSRFToken()
        };
        this.currentSession = null;
        this.sessions = [];
        this.isLoading = false;

        // Performance optimizations for streaming
        this.scrollThrottle = null;
        this.updateQueue = new Map();
        this.isUpdating = false;
        this._markdownCache = null;
        this.streamingStats = {
            messagesReceived: 0,
            lastUpdate: Date.now(),
            updateTimes: []
        };

        // Configure marked.js for better markdown rendering
        this.configureMarkdownRenderer();

        this.initializeEventListeners();
        this.loadSessions();
    }

    getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value ||
               document.querySelector('meta[name="csrf-token"]')?.content || '';
    }

    configureMarkdownRenderer() {
        // Configure marked.js for better rendering
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false,
                sanitize: false, // We'll use DOMPurify for sanitization
            });

            // Custom renderer for better styling
            const renderer = new marked.Renderer();

            // Custom table rendering with proper CSS classes
            renderer.table = function(header, body) {
                return `
                    <div class="table-container">
                        <table class="markdown-table">
                            <thead>${header}</thead>
                            <tbody>${body}</tbody>
                        </table>
                    </div>
                `;
            };

            // Custom table row rendering
            renderer.tablerow = function(content) {
                return `<tr class="table-row">${content}</tr>`;
            };

            // Custom table cell rendering
            renderer.tablecell = function(content, flags) {
                const type = flags.header ? 'th' : 'td';
                const className = flags.header ? 'table-header' : 'table-cell';
                const align = flags.align ? ` style="text-align: ${flags.align}"` : '';
                return `<${type} class="${className}"${align}>${content}</${type}>`;
            };

            // Custom code block rendering
            renderer.code = function(code, language) {
                return `
                    <div class="code-block-container">
                        <pre class="code-block"><code class="language-${language || 'text'}">${code}</code></pre>
                    </div>
                `;
            };

            // Custom list rendering
            renderer.list = function(body, ordered) {
                const type = ordered ? 'ol' : 'ul';
                return `<${type} class="markdown-list">${body}</${type}>`;
            };

            renderer.listitem = function(text) {
                return `<li class="markdown-list-item">${text}</li>`;
            };

            // Custom paragraph rendering
            renderer.paragraph = function(text) {
                return `<p class="markdown-paragraph">${text}</p>`;
            };

            // Custom heading rendering
            renderer.heading = function(text, level) {
                return `<h${level} class="markdown-heading markdown-h${level}">${text}</h${level}>`;
            };

            // Custom blockquote rendering
            renderer.blockquote = function(quote) {
                return `<blockquote class="markdown-blockquote">${quote}</blockquote>`;
            };

            marked.setOptions({ renderer: renderer });
        }
    }

    initializeEventListeners() {
        // New chat button
        document.getElementById('newChatBtn').addEventListener('click', () => {
            this.createNewSession();
        });

        // Welcome form submission
        document.getElementById('welcomeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('welcomeInput');
            if (input.value.trim()) {
                this.createSessionAndSendMessage(input.value.trim());
                input.value = '';
            }
        });

        // Chat form submission
        document.getElementById('chatForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            if (input.value.trim() && this.currentSession) {
                this.sendMessage(input.value.trim());
                input.value = '';
                this.autoResizeTextarea(input);
            }
        });

        // Auto-resize textarea
        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', () => {
            this.autoResizeTextarea(messageInput);
        });
    }

    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    async loadSessions() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                headers: this.headers
            });

            if (response.ok) {
                const data = await response.json();
                this.sessions = data.results || data;
                console.log('Loaded sessions:', this.sessions.length, 'sessions');
                this.updateSessionsList();
            } else if (response.status === 401) {
                this.showErrorToast('Please log in to access chat sessions');
                window.location.href = '/admin/login/';
            } else if (response.status === 403) {
                this.updateSessionsList(); // Show empty state
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
            this.updateSessionsList(); // Show empty state
        }
    }

    updateSessionsList() {
        const container = document.getElementById('sessionsList');

        if (!Array.isArray(this.sessions)) {
            this.sessions = [];
        }

        if (this.sessions.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fa-regular fa-message text-4xl mb-2"></i>
                    <p>No sessions yet</p>
                    <p class="text-sm">Create your first chat</p>
                </div>
            `;
            return;
        }

        container.innerHTML = this.sessions.map(session => `
            <div class="session-item py-2 px-2 rounded-lg cursor-pointer transition-colors border-b   mb-2 ${
                this.currentSession?.id === session.id ? 'bg-primary-light border border-primary ' : 'hover:bg-gray-50'
            }" data-session-id="${session.id}" onclick="window.unifiedChat.loadSession(${session.id})">
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                <h6 class="font-medium text-gray-800">
                ${ (session.title && session.title.length > 25)
                    ? session.title.substring(0, 25) + "..."
                    : (session.title || "Untitled Session") }
                </h6>

                        <p class="text-xs text-gray-400">${this.formatDate(session.created_at)}</p>
                    </div>
                    <div class="flex items-center space-x-1 ml-2">
                        <button class="session-delete-btn p-1 text-gray-400 hover:text-red-500"
                                onclick="event.stopPropagation(); window.unifiedChat.deleteSession(${session.id})">
                            <svg xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 24 24"
     fill="none"
     stroke="currentColor"
     stroke-width="1.5"
     stroke-linecap="round"
     stroke-linejoin="round"
     style="width:20px; height:20px; color:#dc2626; cursor:pointer;">
  <path d="M4 7h16M10 11v6M14 11v6M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
</svg>

                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }

    async createNewSession() {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            this.showSuccessToast('New chat session created');
        } catch (error) {
            console.error('Error creating new session:', error);
            this.showErrorToast('Failed to create new session');
        } finally {
            this.hideLoading();
        }
    }

    async createSessionAndSendMessage(userInput) {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            await this.sendMessage(userInput);
        } catch (error) {
            console.error('Error creating session and sending message:', error);
            this.showErrorToast('Failed to start conversation');
        } finally {
            this.hideLoading();
        }
    }

    async createSession() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ title: null })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to create session`);
            }

            const session = await response.json();
            this.currentSession = session;
            this.sessions.unshift(session);
            this.updateSessionsList();
            this.updateChatTitle(session.title || 'New Chat');

            return session;
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }

    async loadSession(sessionId) {
        try {
            this.showLoading();
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/`, {
                headers: this.headers
            });

            if (response.ok) {
                const session = await response.json();
                this.currentSession = session;
                this.showChatInterface();
                this.loadSessionMessages(session);
                this.updateSessionsList();
                this.updateChatTitle(session.title || 'Untitled Session');
            } else {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to load session`);
            }
        } catch (error) {
            console.error('Error loading session:', error);
            this.showErrorToast('Failed to load session');
        } finally {
            this.hideLoading();
        }
    }

    loadSessionMessages(session) {
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';

        if (session.messages && session.messages.length > 0) {
            // Sort messages by creation date (oldest first)
            const sortedMessages = [...session.messages].sort((a, b) =>
                new Date(a.created_at) - new Date(b.created_at)
            );

            sortedMessages.forEach(message => {
                // Add user message
                this.addMessageToUI({
                    id: message.id,
                    user_input: message.user_input,
                    created_at: message.created_at,
                    status: message.status
                });

                // Add assistant message if it exists
                if (message.assistant_response && message.assistant_response.trim()) {
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response,
                        created_at: message.created_at,
                        status: message.status,
                        visulization: message.visulization
                    });

                    // Add visualization if it exists
                    if (message.visulization) {
                        setTimeout(() => {
                            this.addVisualizationToMessage(message.id + '_assistant', message.visulization);
                        }, 100);
                    }
                } else if (message.status === 'failed') {
                    // Show failed message
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response || "This message failed to process. Please try again.",
                        created_at: message.created_at,
                        status: 'failed'
                    });
                }
            });
        }

        this.scrollToBottom();
    }

    async sendMessage(userInput) {
        if (!this.currentSession || this.isLoading) return;

        this.isLoading = true;
        this.setSendButtonLoading(true);

        // Add user message to UI
        const userMessage = {
            id: Date.now(),
            user_input: userInput,
            created_at: new Date().toISOString(),
            status: 'pending'
        };
        this.addMessageToUI(userMessage);

        // Add assistant message placeholder
        const assistantMessage = {
            id: Date.now() + 1,
            user_input: '',
            assistant_response: '',
            created_at: new Date().toISOString(),
            status: 'processing',
            visualizations: [],
            toolResponses: []
        };
        this.addMessageToUI(assistantMessage);

        // Ensure the message DOM is ready for streaming updates
        setTimeout(() => {
            const messageDiv = document.getElementById(`message-${assistantMessage.id}`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.message-content');
                if (contentDiv) {
                    console.log(`✅ Assistant message ${assistantMessage.id} DOM ready for streaming`);
                } else {
                    console.warn(`⚠️ Content div not found for message ${assistantMessage.id}`);
                }
            }
        }, 10);

        try {
            const response = await fetch(
                `${this.apiBaseUrl}/insights/sessions/${this.currentSession.id}/messages/`,
                {
                    method: 'POST',
                    headers: this.headers,
                    body: JSON.stringify({
                        user_input: userInput,
                        ai_answer: true
                    })
                }
            );

            if (!response.ok) {
                throw new Error('Failed to send message');
            }

            await this.handleStreamingResponse(response, assistantMessage);

        } catch (error) {
            console.error('Error sending message:', error);
            this.showErrorToast('Failed to send message');
            this.updateMessageStatus(assistantMessage.id, 'failed');
        } finally {
            this.isLoading = false;
            this.setSendButtonLoading(false);
        }
    }

    async handleStreamingResponse(response, assistantMessage) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let messageCount = 0;

        try {
            while (true) {
                const { done, value } = await reader.read();

                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                // Process lines in batches for better performance
                const linesToProcess = lines.filter(line => line.trim());

                for (const line of linesToProcess) {
                    try {
                        const message = JSON.parse(line);
                        messageCount++;
                        
                        // Debug logging to catch object issues
                        if (message.action === 'llm' && typeof message.data === 'object') {
                            console.warn('🚨 LLM action contains object data:', message);
                        }
                        
                        // Handle message immediately for fast rendering
                        this.handleStreamMessage(message, assistantMessage);
                        
                        // Yield control to browser every 10 messages for responsiveness
                        if (messageCount % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                    } catch (e) {
                        console.warn('Failed to parse stream message:', line, e);
                        // Try to handle malformed JSON
                        if (line.includes('"action"') && line.includes('"data"')) {
                            console.log('Attempting to recover malformed message:', line);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Streaming error:', error);
            this.updateMessageStatus(assistantMessage.id, 'failed');
        }
    }

    handleStreamMessage(message, assistantMessage) {
        const { action, data } = message;

        // Skip null/undefined data
        if (data === null || data === undefined) {
            return;
        }

        switch (action) {
            case 'tool_response':
                // Store tool responses for chart data extraction
                assistantMessage.toolResponses = assistantMessage.toolResponses || [];
                assistantMessage.toolResponses.push(data);

                // Show a subtle indicator that tools are working
                this.showToolActivity(assistantMessage.id);
                break;

            case 'llm':
                // Performance tracking
                const startTime = performance.now();
                this.streamingStats.messagesReceived++;
                
                // Ensure data is a string, not an object
                let textData = data;
                if (typeof data === 'object') {
                    console.warn('Received object in LLM stream, converting to string:', data);
                    textData = JSON.stringify(data);
                } else if (data === null || data === undefined) {
                    textData = '';
                } else {
                    textData = String(data);
                }
                
                // Accumulate the response
                if (!assistantMessage.assistant_response) {
                    assistantMessage.assistant_response = '';
                }
                assistantMessage.assistant_response += textData;
                
                // Update UI immediately for fast rendering
                this.updateMessageContent(assistantMessage.id, assistantMessage.assistant_response);
                
                // Track performance
                const updateTime = performance.now() - startTime;
                this.streamingStats.updateTimes.push(updateTime);
                this.streamingStats.lastUpdate = Date.now();
                
                // Log performance if updates are slow
                if (updateTime > 50) {
                    console.warn(`Slow streaming update: ${updateTime.toFixed(2)}ms for message ${assistantMessage.id}`);
                }
                
                // Debug logging for object issues
                if (typeof data === 'object') {
                    console.log('📊 LLM stream data type issue - Data:', data, 'Converted to:', textData);
                }
                break;

            case 'visualization':
                assistantMessage.visualizations = assistantMessage.visualizations || [];
                assistantMessage.visualizations.push(data);

                // Add visualization immediately
                this.addVisualizationToMessage(assistantMessage.id, data, assistantMessage.toolResponses);
                break;

            case 'completed':
                this.updateMessageStatus(assistantMessage.id, 'completed');
                this.hideToolActivity(assistantMessage.id);

                // Refresh sessions list asynchronously to avoid blocking
                setTimeout(() => this.loadSessions(), 100);
                break;

            case 'error':
                console.error('Stream error:', data);
                this.updateMessageStatus(assistantMessage.id, 'failed');
                this.hideToolActivity(assistantMessage.id);
                break;

            default:
                console.debug('Unknown stream action:', action, data);
        }
    }

 addMessageToUI(message) {
  const container = document.getElementById('messagesContainer');
  const messageDiv = document.createElement('div');
  messageDiv.id = `message-${message.id}`;

  if (message.user_input && !message.assistant_response) {
    // 🧑 User message → right aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-end; margin-bottom:1rem;">
        <div style="max-width:70%; text-align:right; min-width:0;">
          <div
            style="
              background-color:#d9fdd3;   /* WhatsApp user green */
              border:1px solid #b7e6a1;
              border-top-left-radius:0.75rem;
              border-bottom-right-radius:0.75rem;
              border-bottom-left-radius:0.75rem;
              padding:0.75rem 1rem;
              box-shadow:0 1px 2px rgba(0,0,0,0.05);
              color:#111827;
              font-size:0.95rem;
              word-wrap:break-word;
              overflow-wrap:break-word;
              max-width:100%;
            "
          >
            ${this.escapeHtml(message.user_input)}
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
        <div style="flex-shrink:0; margin-left:0.75rem;">
          <div class="rounded-full border border-primary" style="width:2rem; height:2rem; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
            <img src="{% static 'assets/img/rail.png' %}" alt="User" style="width:1.5rem; height:1.5rem;"/>

          </div>
        </div>
      </div>
    `;
  } else {
    // 🤖 Assistant message → left aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-start; margin-bottom:1rem;">
        <div style="flex-shrink:0; margin-right:0.75rem;">
          <div class="border border-primary rounded-full" style="width:2rem; height:2rem; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
                        <img src="{% static 'assets/img/ai.png' %}" alt="User" style="width:1.5rem; height:1.5rem;"/>

          </div>
        </div>
        <div style="max-width:70%; min-width:0; flex:1;">
          <div style="
            background-color:#ffffff;   /* WhatsApp assistant white */
            border:1px solid #e5e7eb;
            border-top-right-radius:0.75rem;
            border-bottom-right-radius:0.75rem;
            border-bottom-left-radius:0.75rem;
            padding:0.75rem 1rem;
            box-shadow:0 1px 2px rgba(0,0,0,0.05);
            color:#111827;
            font-size:0.95rem;
            word-wrap:break-word;
            overflow-wrap:break-word;
            max-width:100%;
          ">
            <div class="message-content">
              ${message.assistant_response ? this.formatMarkdown(message.assistant_response) :
                '<div style="display:flex; align-items:center; gap:0.5rem;"><span style="color:#6b7280;">Thinking</span><div class="thinking-dots"><span>.</span><span>.</span><span>.</span></div></div>'}
            </div>
            <div class="visualizations-container" style="margin-top:1rem;"></div>
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
      </div>
    `;
  }

  container.appendChild(messageDiv);
  this.scrollToBottom();
}

    updateMessageContent(messageId, content) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (!messageDiv) {
            console.warn(`Message div not found: message-${messageId}`);
            return;
        }

        // Try multiple selectors to find the content div
        let contentDiv = messageDiv.querySelector('.message-content');

        if (!contentDiv) {
            // Fallback: look for any div that might contain the content
            contentDiv = messageDiv.querySelector('div > div > div > div');
        }

        if (!contentDiv) {
            // Last resort: create the content structure if it doesn't exist
            const messageContainer = messageDiv.querySelector('div > div > div');
            if (messageContainer) {
                contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                messageContainer.innerHTML = '';
                messageContainer.appendChild(contentDiv);
            }
        }

        if (contentDiv) {
            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                try {
                    // Immediately display the content as it streams in
                    contentDiv.innerHTML = this.formatMarkdown(content);

                    // Ensure the message container maintains its styling
                    const messageContainer = contentDiv.closest('div[style*="background-color:#ffffff"]');
                    if (messageContainer) {
                        // Maintain consistent styling during streaming
                        messageContainer.style.wordWrap = 'break-word';
                        messageContainer.style.overflowWrap = 'break-word';
                        messageContainer.style.maxWidth = '100%';
                    }

                    // Auto-scroll to show new content (throttled)
                    this.throttledScrollToBottom();
                } catch (error) {
                    console.error('Error updating message content:', error);
                    // Fallback: just set text content
                    contentDiv.textContent = content;
                }
            });
        } else {
            console.error(`Could not find content div for message ${messageId}`);
        }
    }

    updateMessageStatus(messageId, status) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            // Find the message-content div in the new structure
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv && status === 'failed') {
                contentDiv.innerHTML = '<div style="color:#ef4444;">Failed to process message. Please try again.</div>';
            }
        }
    }

    addVisualizationToMessage(messageId, visualizationData, toolResponses = []) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const container = messageDiv.querySelector('.visualizations-container');
            if (container) {
                const chartId = `chart-${messageId}-${Date.now()}`;
                const vizDiv = document.createElement('div');
                vizDiv.className = 'visualization mb-6 p-4 bg-gradient-to-r from-green-600 to-lime-400 rounded-lg ';
                vizDiv.innerHTML = `
                    <div class="flex items-center mb-3">
                        <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                        <h4 class="font-semibold text-white text-gray-800"> ${visualizationData.visualization_name || 'Data Visualization'}</h4>
                    </div>
                    <div class="chart-container bg-white p-4 rounded-lg shadow-sm">
                        <canvas id="${chartId}" width="400" height="200"></canvas>
                    </div>
                    <div class="mt-3   text-base  text-white text-gray-600">
                        <p>${visualizationData.frontend_data?.description || visualizationData.recommendation?.reasoning || 'Interactive chart based on your audio data'}</p>
                    </div>
                `;
                container.appendChild(vizDiv);

                // Create the chart with actual data
                setTimeout(() => {
                    this.createChart(visualizationData, chartId, toolResponses);
                }, 100);
            }
        }
    }

    createChart(visualizationData, canvasId, toolResponses = []) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        try {
            const frontendData = visualizationData.frontend_data;
            const chartType = frontendData.type;

            // Extract actual data from the tool responses
            const actualData = this.extractChartData(visualizationData, toolResponses);

            console.log('Creating chart:', chartType, 'with data:', actualData);

            // Create chart configuration based on type
            let config;

            switch (chartType) {
                case 'pie_chart':
                    config = {
                        type: 'pie',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' },
                                    padding: { bottom: 20 }
                                }
                            }
                        }
                    };
                    break;

                case 'bar_chart':
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors[0] || '#36A2EB',
                                borderColor: actualData.colors[0] || '#36A2EB',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;

                case 'line_chart':
                    config = {
                        type: 'line',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Trend',
                                data: actualData.data,
                                borderColor: actualData.colors[0] || '#36A2EB',
                                backgroundColor: (actualData.colors[0] || '#36A2EB') + '20',
                                tension: 0.4,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;

                default:
                    // Default to bar chart
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
            }

            // Create the chart
            new Chart(canvas, config);

            console.log('Chart created successfully:', canvasId);
        } catch (error) {
            console.error('Error creating chart:', error);
            // Show error message in the chart container
            const container = canvas.parentElement;
            container.innerHTML = '<div class="text-red-500 text-center p-4">Failed to load chart</div>';
        }
    }

    extractChartData(visualizationData, toolResponses = []) {
        console.log('Extracting chart data from:', visualizationData, 'Tool responses:', toolResponses);

        // Try to extract actual data from tool responses
        let extractedData = null;

        for (const toolResponse of toolResponses) {
            // Handle array responses (like region counts)
            if (Array.isArray(toolResponse)) {
                try {
                    if (toolResponse.length > 0 && toolResponse[0].region_name) {
                        // Extract region data from array format
                        const labels = toolResponse.map(item => item.region_name);
                        const data = toolResponse.map(item => item.noise_dataset_count);

                        extractedData = {
                            labels: labels,
                            data: data,
                            colors: this.generateColors(labels.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error parsing array response:', e);
                }
            }
            // Handle object responses with datasets
            else if (typeof toolResponse === 'object' && toolResponse.datasets) {
                try {
                    const datasets = toolResponse.datasets;
                    if (Array.isArray(datasets)) {
                        const regions = datasets.map(d => d.region);
                        const uniqueRegions = [...new Set(regions)];
                        const counts = uniqueRegions.map(region =>
                            regions.filter(r => r === region).length
                        );

                        extractedData = {
                            labels: uniqueRegions,
                            data: counts,
                            colors: this.generateColors(uniqueRegions.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error processing dataset response:', e);
                }
            }
            // Handle string responses
            else if (typeof toolResponse === 'string') {
                try {
                    // Parse string responses that might contain data
                    if (toolResponse.includes('datasets') && toolResponse.includes('region')) {
                        // Extract region data from the tool response
                        const match = toolResponse.match(/'region':\s*'([^']+)'/g);
                        if (match) {
                            const regions = match.map(m => m.match(/'region':\s*'([^']+)'/)[1]);
                            const uniqueRegions = [...new Set(regions)];
                            const counts = uniqueRegions.map(region =>
                                regions.filter(r => r === region).length
                            );

                            extractedData = {
                                labels: uniqueRegions,
                                data: counts,
                                colors: this.generateColors(uniqueRegions.length),
                                title: 'Distribution of Audio Files by Region'
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.log('Error parsing tool response:', e);
                }
            }
        }

        // If we extracted data, return it
        if (extractedData) {
            return extractedData;
        }

        // Check if there's a chart_template in the recommendation with actual data
        const recommendation = visualizationData.recommendation;
        if (recommendation && recommendation.chart_template) {
            const template = recommendation.chart_template;
            if (template.data && template.data.labels && template.data.values) {
                return {
                    labels: template.data.labels,
                    data: template.data.values,
                    colors: template.data.colors || this.generateColors(template.data.labels.length),
                    title: template.layout?.title || 'Audio Data Distribution'
                };
            }
        }

        // Fallback: Use the data from the sample response (Ashanti region with 2 files)
        return {
            labels: ['Ashanti'],
            data: [2],
            colors: ['#FF6384'],
            title: 'Distribution of Audio Files by Region'
        };
    }

    generateColors(count) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
            '#4BC0C0', '#FF6384', '#36A2EB', '#FFCE56'
        ];
        return colors.slice(0, count);
    }

    async deleteSession(sessionId) {
        if (!confirm('Are you sure you want to delete this session?')) return;

        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/archive/`, {
                method: 'POST',
                headers: this.headers
            });

            if (response.ok) {
                this.sessions = this.sessions.filter(s => s.id !== sessionId);
                if (this.currentSession?.id === sessionId) {
                    this.currentSession = null;
                    this.showWelcomeScreen();
                }
                this.updateSessionsList();
                this.showSuccessToast('Session deleted successfully');
            }
        } catch (error) {
            console.error('Error deleting session:', error);
            this.showErrorToast('Failed to delete session');
        }
    }

    showWelcomeScreen() {
        document.getElementById('welcomeScreen').classList.remove('hidden');
        document.getElementById('chatContainer').classList.add('hidden');
        document.getElementById('chatInputContainer').classList.add('hidden');
        document.getElementById('messagesContainer').innerHTML = '';
        this.updateChatTitle('Welcome to Data Insights!');
    }

    showChatInterface() {
        document.getElementById('welcomeScreen').classList.add('hidden');
        document.getElementById('chatContainer').classList.remove('hidden');
        document.getElementById('chatInputContainer').classList.remove('hidden');
    }

    updateChatTitle(title) {
        document.getElementById('chatTitle').textContent = title;
    }

    scrollToBottom() {
        const container = document.getElementById('chatContainer');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }

    throttledScrollToBottom() {
        // Throttle scrolling for better performance during rapid streaming
        if (this.scrollThrottle) {
            clearTimeout(this.scrollThrottle);
        }

        this.scrollThrottle = setTimeout(() => {
            this.scrollToBottom();
        }, 16); // ~60fps
    }

    showToolActivity(messageId) {
        // Show a subtle indicator that AI tools are working
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            let indicator = messageDiv.querySelector('.tool-activity-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'tool-activity-indicator';
                indicator.innerHTML = '<div style="font-size:0.75rem; color:#6b7280; margin-top:0.25rem;"><span>🔧</span> Analyzing data...</div>';

                const contentContainer = messageDiv.querySelector('.message-content');
                if (contentContainer && contentContainer.parentNode) {
                    contentContainer.parentNode.appendChild(indicator);
                }
            }
        }
    }

    hideToolActivity(messageId) {
        // Hide the tool activity indicator
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const indicator = messageDiv.querySelector('.tool-activity-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
    }

    setSendButtonLoading(loading) {
        const btn = document.getElementById('sendBtn');
        if (loading) {
            btn.disabled = true;
            btn.innerHTML = '<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>';
        } else {
            btn.disabled = false;
            btn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        }
    }

    showLoading() {
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }

    hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }

    showErrorToast(message) {
        const toast = document.getElementById('errorToast');
        const messageEl = document.getElementById('errorMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');

        setTimeout(() => {
            toast.classList.add('hidden');
        }, 5000);
    }

    showSuccessToast(message) {
        const toast = document.getElementById('successToast');
        const messageEl = document.getElementById('successMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');

        setTimeout(() => {
            toast.classList.add('hidden');
        }, 3000);
    }

    formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 1) return 'Today';
        if (diffDays === 2) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays - 1} days ago`;

        return date.toLocaleDateString();
    }

    formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
            hour12: true
        });
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    formatMarkdown(text) {
        // Professional markdown formatting with proper table support
        if (!text || typeof text !== 'string') {
            return '';
        }

        // Cache for performance during streaming
        if (this._markdownCache && this._markdownCache.input === text) {
            return this._markdownCache.output;
        }

        try {
            let cleanText = text;

            // Remove chart configuration JSON blocks (they're handled by visualizations)
            cleanText = cleanText.replace(/```json\s*\{\s*"recommended_chart"[\s\S]*?```/g, '');
            cleanText = cleanText.replace(/```json\s*\{\s*"type":\s*"(pie|bar|line|heatmap|scatter|box|area)"[\s\S]*?```/g, '');

            // Remove chart reasoning sections
            cleanText = cleanText.replace(/### Recommended Visualization:[\s\S]*?(?=###|$)/g, '');
            cleanText = cleanText.replace(/#### [^:]*Chart Configuration:[\s\S]*?(?=###|####|$)/g, '');
            cleanText = cleanText.replace(/Here's the template for creating[\s\S]*?```/g, '');

            // Use marked.js for proper markdown rendering
            let formattedText;
            if (typeof marked !== 'undefined') {
                formattedText = marked.parse(cleanText);

                // Sanitize the HTML for security
                if (typeof DOMPurify !== 'undefined') {
                    formattedText = DOMPurify.sanitize(formattedText, {
                        ALLOWED_TAGS: [
                            'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                            'ul', 'ol', 'li', 'blockquote', 'pre', 'code', 'table', 'thead', 'tbody',
                            'tr', 'th', 'td', 'div', 'span', 'a', 'img'
                        ],
                        ALLOWED_ATTR: ['class', 'style', 'href', 'src', 'alt', 'title']
                    });
                }
            } else {
                // Fallback to basic formatting if marked.js isn't loaded
                formattedText = this.basicMarkdownFormat(cleanText);
            }

            // Cache the result
            this._markdownCache = { input: text, output: formattedText };

            return formattedText;

        } catch (error) {
            console.warn('Markdown formatting error:', error);
            // Fallback: basic text formatting
            return this.basicMarkdownFormat(text);
        }
    }

    basicMarkdownFormat(text) {
        // Basic fallback markdown formatting
        return text
            .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>')
            .replace(/\*(.*?)\*/g, '<em class="italic">$1</em>')
            .replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>')
            .replace(/^###\s+(.+)$/gm, '<h3 class="markdown-h3">$1</h3>')
            .replace(/^##\s+(.+)$/gm, '<h2 class="markdown-h2">$1</h2>')
            .replace(/^#\s+(.+)$/gm, '<h1 class="markdown-h1">$1</h1>')
            .replace(/^-\s+(.+)$/gm, '<li class="markdown-list-item">• $1</li>')
            .replace(/\n\n/g, '</p><p class="markdown-paragraph">')
            .replace(/\n/g, '<br>')
            .replace(/^(?!<)(.+)$/gm, '<p class="markdown-paragraph">$1</p>')
            .replace(/<p class="markdown-paragraph"><\/p>/g, '');
    }

    getStreamingStats() {
        const stats = this.streamingStats;
        const avgUpdateTime = stats.updateTimes.length > 0
            ? stats.updateTimes.reduce((a, b) => a + b, 0) / stats.updateTimes.length
            : 0;

        return {
            messagesReceived: stats.messagesReceived,
            averageUpdateTime: avgUpdateTime.toFixed(2) + 'ms',
            lastUpdate: new Date(stats.lastUpdate).toLocaleTimeString(),
            totalUpdates: stats.updateTimes.length
        };
    }

    debugStreamingPerformance() {
        console.log('🚀 Streaming Performance Stats:', this.getStreamingStats());
    }
}

// Global functions for suggestion handling
function startChatWithSuggestion(suggestion) {
    window.unifiedChat.createSessionAndSendMessage(suggestion);
}

// Debug function for streaming issues
function debugStreamingDOM() {
    const chat = window.unifiedChat;
    if (chat) {
        console.log('🔍 Streaming Debug Info:');
        console.log('Current session:', chat.currentSession);
        console.log('Is loading:', chat.isLoading);
        console.log('Performance stats:', chat.getStreamingStats());

        // Check DOM structure
        const messagesContainer = document.getElementById('messagesContainer');
        console.log('Messages container:', messagesContainer);
        console.log('Message count in DOM:', messagesContainer?.children.length || 0);

        // Check for message divs
        const messageDivs = document.querySelectorAll('[id^="message-"]');
        console.log('Message divs found:', messageDivs.length);

        messageDivs.forEach((div, index) => {
            const contentDiv = div.querySelector('.message-content');
            console.log(`Message ${index + 1}:`, {
                id: div.id,
                hasContentDiv: !!contentDiv,
                contentLength: contentDiv?.textContent?.length || 0
            });
        });
    }
}

// Add to global scope for debugging
window.debugStreamingDOM = debugStreamingDOM;

// Initialize the unified chat when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.unifiedChat = new UnifiedAudioDataChat();

    // Add global debugging
    window.debugStreaming = () => window.unifiedChat.debugStreamingPerformance();

    console.log('🎵 Unified Audio Data Chat initialized');
    console.log('💡 Debug commands available: debugStreamingDOM(), debugStreaming()');
});
</script>

<style>
/* Custom styles for the unified chat interface */
.message {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.session-item {
    transition: all 0.2s ease;
}

.session-item:hover {
    transform: translateX(2px);
}


.chart-container {
    position: relative;
    height: 300px;
    min-height: 250px;
}

.chart-container canvas {
    max-height: 300px;
}

/* Thinking animation */
.thinking-dots {
    display: inline-flex;
    gap: 2px;
}

.thinking-dots span {
    animation: thinking 1.4s ease-in-out infinite;
    color: #6b7280;
    font-weight: bold;
    font-size: 1.2em;
}

.thinking-dots span:nth-child(1) {
    animation-delay: 0s;
}

.thinking-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.thinking-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes thinking {
    0%, 60%, 100% {
        opacity: 0.3;
        transform: translateY(0);
    }
    30% {
        opacity: 1;
        transform: translateY(-4px);
    }
}

/* Message content styling for streaming - optimized for performance */
.message-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    white-space: pre-wrap;
    line-height: 1.6;
    /* GPU acceleration for smoother updates */
    transform: translateZ(0);
    will-change: contents;
    /* Optimize text rendering */
    text-rendering: optimizeSpeed;
}

/* Ensure messages don't break layout during streaming */
#messagesContainer {
    overflow-x: hidden;
    word-wrap: break-word;
}

#messagesContainer > div {
    max-width: 100%;
    overflow: hidden;
}

/* Professional Markdown Styling */

/* Table styling - responsive and professional */
.table-container {
    overflow-x: auto;
    margin: 1.5rem 0;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    border: 1px solid #e5e7eb;
    max-width: 100%;
}

@media (max-width: 768px) {
    .table-container {
        font-size: 0.75rem;
    }

    .table-header,
    .table-cell {
        padding: 0.5rem 0.75rem;
    }
}

.markdown-table {
    width: 100%;
    border-collapse: collapse;
    background-color: white;
    font-size: 0.875rem;
    line-height: 1.5;
}

.table-header {
    background-color: #f8fafc;
    color: #374151;
    font-weight: 600;
    padding: 0.75rem 1rem;
    text-align: left;
    border-bottom: 2px solid #e5e7eb;
    border-right: 1px solid #e5e7eb;
}

.table-header:last-child {
    border-right: none;
}

.table-cell {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #f3f4f6;
    border-right: 1px solid #f3f4f6;
    color: #374151;
}

.table-cell:last-child {
    border-right: none;
}

.table-row:nth-child(even) {
    background-color: #f9fafb;
}

.table-row:hover {
    background-color: #f3f4f6;
}

/* Code styling */
.code-block-container {
    margin: 1.5rem 0;
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.code-block {
    background-color: #f8fafc;
    border: 1px solid #e5e7eb;
    padding: 1.25rem;
    margin: 0;
    overflow-x: auto;
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.6;
    color: #374151;
}

.inline-code {
    background-color: #f1f5f9;
    color: #dc2626;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-size: 0.875rem;
    border: 1px solid #e2e8f0;
}

/* Heading styling */
.markdown-heading {
    color: #111827;
    font-weight: 700;
    margin-top: 2rem;
    margin-bottom: 1rem;
    line-height: 1.25;
}

.markdown-h1 {
    font-size: 2rem;
    border-bottom: 2px solid #e5e7eb;
    padding-bottom: 0.5rem;
}

.markdown-h2 {
    font-size: 1.5rem;
    color: #1f2937;
}

.markdown-h3 {
    font-size: 1.25rem;
    color: #374151;
}

.markdown-h4 {
    font-size: 1.125rem;
    color: #4b5563;
}

/* List styling */
.markdown-list {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.markdown-list-item {
    margin-bottom: 0.5rem;
    line-height: 1.6;
    color: #374151;
}

/* Paragraph styling */
.markdown-paragraph {
    margin-bottom: 1rem;
    line-height: 1.7;
    color: #374151;
}

/* Blockquote styling */
.markdown-blockquote {
    border-left: 4px solid #3b82f6;
    background-color: #f8fafc;
    padding: 1rem 1.5rem;
    margin: 1.5rem 0;
    font-style: italic;
    color: #4b5563;
    border-radius: 0 0.5rem 0.5rem 0;
}

/* Link styling */
.message-content a {
    color: #3b82f6;
    text-decoration: underline;
    text-decoration-color: #93c5fd;
    transition: color 0.2s ease;
}

.message-content a:hover {
    color: #1d4ed8;
    text-decoration-color: #3b82f6;
}

/* Horizontal rule styling */
.message-content hr {
    border: none;
    height: 1px;
    background-color: #e5e7eb;
    margin: 2rem 0;
}

/* Image styling */
.message-content img {
    max-width: 100%;
    height: auto;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    margin: 1rem 0;
}

/* Responsive adjustments */
@media (max-width: 640px) {
    .markdown-h1 { font-size: 1.5rem; }
    .markdown-h2 { font-size: 1.25rem; }
    .markdown-h3 { font-size: 1.125rem; }
    .markdown-h4 { font-size: 1rem; }

    .markdown-paragraph {
        font-size: 0.9rem;
    }

    .table-container {
        margin: 1rem 0;
    }
}

/* Enhanced markdown styling */
.message-content pre {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    overflow-x: auto;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
}

.message-content code {
    background-color: #f1f3f4;
    color: #d73a49;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
}

.message-content pre code {
    background-color: transparent;
    color: #24292e;
    padding: 0;
}

.message-content h1,
.message-content h2,
.message-content h3,
.message-content h4 {
    color: #1f2937;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
}

.message-content h1 { font-size: 1.5rem; }
.message-content h2 { font-size: 1.25rem; }
.message-content h3 { font-size: 1.125rem; }
.message-content h4 { font-size: 1rem; }

.message-content ul, .message-content ol {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.message-content li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.message-content p {
    line-height: 1.6;
    margin-bottom: 1rem;
}

.message-content strong {
    font-weight: 600;
    color: #111827;
}

.message-content em {
    font-style: italic;
    color: #4b5563;
}

/* Scrollbar styling */
#chatContainer::-webkit-scrollbar,
#sessionsList::-webkit-scrollbar {
    width: 6px;
}

#chatContainer::-webkit-scrollbar-track,
#sessionsList::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb,
#sessionsList::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb:hover,
#sessionsList::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>
{% endblock %}
