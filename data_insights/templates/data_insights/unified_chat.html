{% extends 'datacollection/layout.html' %}
{% load static %}
{% csrf_token %}

{% block content %}
<!-- CSRF Token -->
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<nav>
  <!-- breadcrumb -->
  <ol style="margin-bottom: 30px;" class="flex flex-wrap pt-1 mr-12 bg-transparent rounded-lg sm:mr-16">
    <li class="text-sm leading-normal">
      <a class="text-white opacity-50" href="javascript:;">home</a>
    </li>
    <li class="text-sm pl-2 capitalize leading-normal text-white before:float-left before:pr-2 before:text-white before:content-['/']" aria-current="page">Data Insights</li>
  </ol>
</nav>

<div class="flex h-screen bg-gray-50" style="height: calc(100vh - 200px);">
    <!-- Sidebar - Sessions List -->
    <div class="w-80 bg-white border-r border-gray-200 flex flex-col rounded-l-2xl shadow-xl">
        <!-- Header -->
        <div class="p-4 border-b border-gray-200">
            <div class="flex items-center justify-between mb-4">
                <h6 class="text-lg font-semibold text-gray-800">Chat Sessions</h6>
                <button id="newChatBtn" class="inline-flex items-center px-3 py-2 rounded-lg text-white bg-primary hover:opacity-90 shadow-sm text-sm">
                    <i class="fa-regular fa-plus mr-2"></i>
                    New Chat
                </button>
            </div>
        </div>
        
        <!-- Sessions List -->
        <div id="sessionsList" class="flex-1 overflow-y-auto p-4">
            <div class="text-center text-gray-500 py-8">
                <i class="fa-regular fa-message text-4xl mb-2"></i>
                <p>Loading sessions...</p>
            </div>
        </div>
    </div>

    <!-- Main Content Area -->
    <div class="flex-1 flex flex-col bg-white rounded-r-2xl shadow-xl">
        <!-- Chat Header -->
        <div class="bg-white border-b border-gray-200 p-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 id="chatTitle" class="text-xl font-semibold text-gray-800">Welcome to Data Insights!</h1>
                    <p class="text-sm text-gray-500">Ask me anything about your audio data</p>
                </div>
                <div class="flex items-center space-x-2">
                    <span id="connectionStatus" class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <span style="height: 10px; width: 10px;" class="w-2 h-2 bg-primary rounded-full mr-1"></span>
                        Connected
                    </span>
                </div>
            </div>
        </div>

        <!-- Welcome Screen (No Active Session) -->
        <div id="welcomeScreen" class="flex-1 flex flex-col items-center justify-center p-8">
            <div class="text-cente h-full  flex flex-col justify-between  items-center w-full">
                <div class="mb-8 w-full flex flex-col items-center" style="margin-top: 20px;">
                    <i class="fa-solid fa-chart-line text-6xl text-primary mb-4"></i>
                    <h4 class="font-semibold text-gray-800 mb-4">Get Started</h4>
                    <p class="text-gray-600 mb-8 text-sm">Try one of these suggestions or ask your own question:</p>
               
               
                     <div class="flex flex-wrap justify-center gap-3 mb-8">
                    {% for s in suggestions %}
                    <button style="margin-right: 10px;margin-bottom: 10px;" onclick="startChatWithSuggestion('{{ s|escapejs }}')" class="px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        {{ s }}
                    </button>
                    {% endfor %}
                </div>
                </div>

                <!-- Suggestions -->
               

                <!-- Input Form -->
 <form id="welcomeForm" style="width:100%; padding: 5px; margin:0 auto; margin-bottom: 10px;">
  <div style="position:relative; width:100%;">
    <input 
      id="welcomeInput" 
      type="text" 
      placeholder="Type your question..."
      style="
        width:100%;
        background-color:#f8fafc; 
        border:1px solid #e2e8f0; 
        border-radius:9999px;
        padding:1rem 4rem 1rem 1rem;
        outline:none;
        color:#334155;
        font-size:1rem;
      "
    />
    <button 
      type="submit" 
      aria-label="Send"
      style="
        position:absolute; 
        right:0.5rem; 
        top:50%; 
        transform:translateY(-50%);
        width:3rem; 
        height:3rem; 
        border-radius:9999px; 
        background-color:#22c55e; /* secondary color */
        color:#fff; 
        display:flex; 
        align-items:center; 
        justify-content:center; 
        box-shadow:0 1px 3px rgba(0,0,0,0.2);
        cursor:pointer;
      "
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

            </div>
        </div>

        <!-- Chat Messages Area (Active Session) -->
        <div id="chatContainer" class="flex-1 overflow-y-auto p-4 hidden">
            <div id="messagesContainer" class="max-w-4xl mx-auto space-y-4">
                <!-- Messages will be dynamically added here -->
            </div>
        </div>

        <!-- Chat Input (Active Session) -->
        <div id="chatInputContainer" class="bg-white border-t border-gray-200 p-4 hidden">
<form id="chatForm" class="w-full max-w-xl mx-auto">
  <div class="flex items-center w-full bg-slate-50 border border-slate-200 rounded-full px-3 py-2 focus-within:ring-2 focus-within:ring-secondary/30 focus-within:border-secondary">
    <input 
      id="messageInput" 
      type="text" 
      placeholder="Ask about your audio data..."
      class="flex-1 bg-transparent outline-none text-slate-700 text-base px-2"
    />
    <button 
      type="submit" 
      id="sendBtn"
      aria-label="Send"
      class="w-12 h-12 rounded-full bg-secondary text-white flex items-center justify-center shadow hover:opacity-90 disabled:opacity-50"
    >
      <i class="fa-solid fa-paper-plane"></i>
    </button>
  </div>
</form>

</div>

    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
        <span class="text-gray-700">Processing your request...</span>
    </div>
</div>

<!-- Error Toast -->
<div id="errorToast" class="fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-exclamation-triangle"></i>
        <span id="errorMessage"></span>
    </div>
</div>

<!-- Success Toast -->
<div id="successToast" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-check"></i>
        <span id="successMessage"></span>
    </div>
</div>

<!-- Include Chart.js with Box Plot Plugin -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-chart-boxplot@0.2.0/dist/chartjs-chart-boxplot.min.js"></script>

<script>
// Unified Audio Data Chat Implementation
class UnifiedAudioDataChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.headers = {
            'Content-Type': 'application/json',
            'X-CSRFToken': this.getCSRFToken()
        };
        this.currentSession = null;
        this.sessions = [];
        this.isLoading = false;
        
        // Performance optimizations for streaming
        this.scrollThrottle = null;
        this.updateQueue = new Map();
        this.isUpdating = false;
        this._markdownCache = null;
        this.streamingStats = {
            messagesReceived: 0,
            lastUpdate: Date.now(),
            updateTimes: []
        };
        
        this.initializeEventListeners();
        this.loadSessions();
    }
    
    getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
               document.querySelector('meta[name="csrf-token"]')?.content || '';
    }
    
    initializeEventListeners() {
        // New chat button
        document.getElementById('newChatBtn').addEventListener('click', () => {
            this.createNewSession();
        });
        
        // Welcome form submission
        document.getElementById('welcomeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('welcomeInput');
            if (input.value.trim()) {
                this.createSessionAndSendMessage(input.value.trim());
                input.value = '';
            }
        });
        
        // Chat form submission
        document.getElementById('chatForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            if (input.value.trim() && this.currentSession) {
                this.sendMessage(input.value.trim());
                input.value = '';
                this.autoResizeTextarea(input);
            }
        });
        
        // Auto-resize textarea
        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', () => {
            this.autoResizeTextarea(messageInput);
        });
    }
    
    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    async loadSessions() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                headers: this.headers
            });
            
            if (response.ok) {
                const data = await response.json();
                this.sessions = data.results || data;
                console.log('Loaded sessions:', this.sessions.length, 'sessions');
                this.updateSessionsList();
            } else if (response.status === 401) {
                this.showErrorToast('Please log in to access chat sessions');
                window.location.href = '/admin/login/';
            } else if (response.status === 403) {
                this.updateSessionsList(); // Show empty state
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
            this.updateSessionsList(); // Show empty state
        }
    }
    
    updateSessionsList() {
        const container = document.getElementById('sessionsList');
        
        if (!Array.isArray(this.sessions)) {
            this.sessions = [];
        }
        
        if (this.sessions.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fa-regular fa-message text-4xl mb-2"></i>
                    <p>No sessions yet</p>
                    <p class="text-sm">Create your first chat</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = this.sessions.map(session => `
            <div class="session-item py-2 px-2 rounded-lg cursor-pointer transition-colors border-b   mb-2 ${
                this.currentSession?.id === session.id ? 'bg-primary-light border border-primary ' : 'hover:bg-gray-50'
            }" data-session-id="${session.id}" onclick="window.unifiedChat.loadSession(${session.id})">
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                <h6 class="font-medium text-gray-800">
                ${ (session.title && session.title.length > 25) 
                    ? session.title.substring(0, 25) + "..." 
                    : (session.title || "Untitled Session") }
                </h6>

                        <p class="text-xs text-gray-400">${this.formatDate(session.created_at)}</p>
                    </div>
                    <div class="flex items-center space-x-1 ml-2">
                        <button class="session-delete-btn p-1 text-gray-400 hover:text-red-500" 
                                onclick="event.stopPropagation(); window.unifiedChat.deleteSession(${session.id})">
                            <svg xmlns="http://www.w3.org/2000/svg" 
     viewBox="0 0 24 24" 
     fill="none" 
     stroke="currentColor" 
     stroke-width="1.5" 
     stroke-linecap="round" 
     stroke-linejoin="round"
     style="width:20px; height:20px; color:#dc2626; cursor:pointer;">
  <path d="M4 7h16M10 11v6M14 11v6M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
</svg>

                        </button>
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    async createNewSession() {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            this.showSuccessToast('New chat session created');
        } catch (error) {
            console.error('Error creating new session:', error);
            this.showErrorToast('Failed to create new session');
        } finally {
            this.hideLoading();
        }
    }
    
    async createSessionAndSendMessage(userInput) {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.showChatInterface();
            await this.sendMessage(userInput);
        } catch (error) {
            console.error('Error creating session and sending message:', error);
            this.showErrorToast('Failed to start conversation');
        } finally {
            this.hideLoading();
        }
    }
    
    async createSession() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ title: null })
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to create session`);
            }
            
            const session = await response.json();
            this.currentSession = session;
            this.sessions.unshift(session);
            this.updateSessionsList();
            this.updateChatTitle(session.title || 'New Chat');
            
            return session;
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }
    
    async loadSession(sessionId) {
        try {
            this.showLoading();
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/`, {
                headers: this.headers
            });
            
            if (response.ok) {
                const session = await response.json();
                this.currentSession = session;
                this.showChatInterface();
                this.loadSessionMessages(session);
                this.updateSessionsList();
                this.updateChatTitle(session.title || 'Untitled Session');
            } else {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to load session`);
            }
        } catch (error) {
            console.error('Error loading session:', error);
            this.showErrorToast('Failed to load session');
        } finally {
            this.hideLoading();
        }
    }
    
    loadSessionMessages(session) {
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';
        
        if (session.messages && session.messages.length > 0) {
            // Sort messages by creation date (oldest first)
            const sortedMessages = [...session.messages].sort((a, b) => 
                new Date(a.created_at) - new Date(b.created_at)
            );
            
            sortedMessages.forEach(message => {
                // Add user message
                this.addMessageToUI({
                    id: message.id,
                    user_input: message.user_input,
                    created_at: message.created_at,
                    status: message.status
                });
                
                // Add assistant message if it exists
                if (message.assistant_response && message.assistant_response.trim()) {
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response,
                        created_at: message.created_at,
                        status: message.status,
                        visulization: message.visulization
                    });
                    
                    // Add visualization if it exists
                    if (message.visulization) {
                        setTimeout(() => {
                            this.addVisualizationToMessage(message.id + '_assistant', message.visulization);
                        }, 100);
                    }
                } else if (message.status === 'failed') {
                    // Show failed message
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response || "This message failed to process. Please try again.",
                        created_at: message.created_at,
                        status: 'failed'
                    });
                }
            });
        }
        
        this.scrollToBottom();
    }
    
    async sendMessage(userInput) {
        if (!this.currentSession || this.isLoading) return;
        
        this.isLoading = true;
        this.setSendButtonLoading(true);
        
        // Add user message to UI
        const userMessage = {
            id: Date.now(),
            user_input: userInput,
            created_at: new Date().toISOString(),
            status: 'pending'
        };
        this.addMessageToUI(userMessage);
        
        // Add assistant message placeholder
        const assistantMessage = {
            id: Date.now() + 1,
            user_input: '',
            assistant_response: '',
            created_at: new Date().toISOString(),
            status: 'processing',
            visualizations: [],
            toolResponses: []
        };
        this.addMessageToUI(assistantMessage);
        
        // Ensure the message DOM is ready for streaming updates
        setTimeout(() => {
            const messageDiv = document.getElementById(`message-${assistantMessage.id}`);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.message-content');
                if (contentDiv) {
                    console.log(`âœ… Assistant message ${assistantMessage.id} DOM ready for streaming`);
                } else {
                    console.warn(`âš ï¸ Content div not found for message ${assistantMessage.id}`);
                }
            }
        }, 10);
        
        try {
            const response = await fetch(
                `${this.apiBaseUrl}/insights/sessions/${this.currentSession.id}/messages/`,
                {
                    method: 'POST',
                    headers: this.headers,
                    body: JSON.stringify({
                        user_input: userInput,
                        ai_answer: true
                    })
                }
            );
            
            if (!response.ok) {
                throw new Error('Failed to send message');
            }
            
            await this.handleStreamingResponse(response, assistantMessage);
            
        } catch (error) {
            console.error('Error sending message:', error);
            this.showErrorToast('Failed to send message');
            this.updateMessageStatus(assistantMessage.id, 'failed');
        } finally {
            this.isLoading = false;
            this.setSendButtonLoading(false);
        }
    }
    
    async handleStreamingResponse(response, assistantMessage) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let messageCount = 0;
        
        try {
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();
                
                // Process lines in batches for better performance
                const linesToProcess = lines.filter(line => line.trim());
                
                for (const line of linesToProcess) {
                    try {
                        const message = JSON.parse(line);
                        messageCount++;
                        
                        // Handle message immediately for fast rendering
                        this.handleStreamMessage(message, assistantMessage);
                        
                        // Yield control to browser every 10 messages for responsiveness
                        if (messageCount % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                    } catch (e) {
                        console.warn('Failed to parse stream message:', line, e);
                    }
                }
            }
        } catch (error) {
            console.error('Streaming error:', error);
            this.updateMessageStatus(assistantMessage.id, 'failed');
        }
    }
    
    handleStreamMessage(message, assistantMessage) {
        const { action, data } = message;
        
        // Skip null/undefined data
        if (data === null || data === undefined) {
            return;
        }
        
        switch (action) {
            case 'tool_response':
                // Store tool responses for chart data extraction
                assistantMessage.toolResponses = assistantMessage.toolResponses || [];
                assistantMessage.toolResponses.push(data);
                
                // Show a subtle indicator that tools are working
                this.showToolActivity(assistantMessage.id);
                break;
                
            case 'llm':
                // Performance tracking
                const startTime = performance.now();
                this.streamingStats.messagesReceived++;
                
                // Accumulate the response
                if (!assistantMessage.assistant_response) {
                    assistantMessage.assistant_response = '';
                }
                assistantMessage.assistant_response += data;
                
                // Update UI immediately for fast rendering
                this.updateMessageContent(assistantMessage.id, assistantMessage.assistant_response);
                
                // Track performance
                const updateTime = performance.now() - startTime;
                this.streamingStats.updateTimes.push(updateTime);
                this.streamingStats.lastUpdate = Date.now();
                
                // Log performance if updates are slow
                if (updateTime > 50) {
                    console.warn(`Slow streaming update: ${updateTime.toFixed(2)}ms for message ${assistantMessage.id}`);
                }
                break;
                
            case 'visualization':
                assistantMessage.visualizations = assistantMessage.visualizations || [];
                assistantMessage.visualizations.push(data);
                
                // Add visualization immediately
                this.addVisualizationToMessage(assistantMessage.id, data, assistantMessage.toolResponses);
                break;
                
            case 'completed':
                this.updateMessageStatus(assistantMessage.id, 'completed');
                this.hideToolActivity(assistantMessage.id);
                
                // Refresh sessions list asynchronously to avoid blocking
                setTimeout(() => this.loadSessions(), 100);
                break;
                
            case 'error':
                console.error('Stream error:', data);
                this.updateMessageStatus(assistantMessage.id, 'failed');
                this.hideToolActivity(assistantMessage.id);
                break;
                
            default:
                console.debug('Unknown stream action:', action, data);
        }
    }
    
 addMessageToUI(message) {
  const container = document.getElementById('messagesContainer');
  const messageDiv = document.createElement('div');
  messageDiv.id = `message-${message.id}`;

  if (message.user_input && !message.assistant_response) {
    // ðŸ§‘ User message â†’ right aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-end; margin-bottom:1rem;">
        <div style="max-width:70%; text-align:right; min-width:0;">
          <div 
            style="
              background-color:#d9fdd3;   /* WhatsApp user green */
              border:1px solid #b7e6a1;
              border-top-left-radius:0.75rem; 
              border-bottom-right-radius:0.75rem; 
              border-bottom-left-radius:0.75rem;
              padding:0.75rem 1rem; 
              box-shadow:0 1px 2px rgba(0,0,0,0.05); 
              color:#111827; 
              font-size:0.95rem;
              word-wrap:break-word;
              overflow-wrap:break-word;
              max-width:100%;
            "
          >
            ${this.escapeHtml(message.user_input)}
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
        <div style="flex-shrink:0; margin-left:0.75rem;">
          <div class="rounded-full border border-primary" style="width:2rem; height:2rem; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
            <img src="{% static 'assets/img/rail.png' %}" alt="User" style="width:1.5rem; height:1.5rem;"/>

          </div>
        </div>
      </div>
    `;
  } else {
    // ðŸ¤– Assistant message â†’ left aligned
    messageDiv.innerHTML = `
      <div style="display:flex; justify-content:flex-start; margin-bottom:1rem;">
        <div style="flex-shrink:0; margin-right:0.75rem;">
          <div class="border border-primary rounded-full" style="width:2rem; height:2rem; border-radius:9999px; display:flex; align-items:center; justify-content:center;">
                        <img src="{% static 'assets/img/ai.png' %}" alt="User" style="width:1.5rem; height:1.5rem;"/>

          </div>
        </div>
        <div style="max-width:70%; min-width:0; flex:1;">
          <div style="
            background-color:#ffffff;   /* WhatsApp assistant white */
            border:1px solid #e5e7eb;
            border-top-right-radius:0.75rem; 
            border-bottom-right-radius:0.75rem; 
            border-bottom-left-radius:0.75rem;
            padding:0.75rem 1rem; 
            box-shadow:0 1px 2px rgba(0,0,0,0.05); 
            color:#111827; 
            font-size:0.95rem;
            word-wrap:break-word;
            overflow-wrap:break-word;
            max-width:100%;
          ">
            <div class="message-content">
              ${message.assistant_response ? this.formatMarkdown(message.assistant_response) : 
                '<div style="display:flex; align-items:center; gap:0.5rem;"><span style="color:#6b7280;">Thinking</span><div class="thinking-dots"><span>.</span><span>.</span><span>.</span></div></div>'}
            </div>
            <div class="visualizations-container" style="margin-top:1rem;"></div>
          </div>
          <p style="font-size:0.75rem; color:#667781; margin-top:0.25rem;">
            ${this.formatTime(message.created_at)}
          </p>
        </div>
      </div>
    `;
  }

  container.appendChild(messageDiv);
  this.scrollToBottom();
}

    updateMessageContent(messageId, content) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (!messageDiv) {
            console.warn(`Message div not found: message-${messageId}`);
            return;
        }

        // Try multiple selectors to find the content div
        let contentDiv = messageDiv.querySelector('.message-content');
        
        if (!contentDiv) {
            // Fallback: look for any div that might contain the content
            contentDiv = messageDiv.querySelector('div > div > div > div');
        }
        
        if (!contentDiv) {
            // Last resort: create the content structure if it doesn't exist
            const messageContainer = messageDiv.querySelector('div > div > div');
            if (messageContainer) {
                contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                messageContainer.innerHTML = '';
                messageContainer.appendChild(contentDiv);
            }
        }

        if (contentDiv) {
            // Use requestAnimationFrame for smooth updates
            requestAnimationFrame(() => {
                try {
                    // Immediately display the content as it streams in
                    contentDiv.innerHTML = this.formatMarkdown(content);
                    
                    // Ensure the message container maintains its styling
                    const messageContainer = contentDiv.closest('div[style*="background-color:#ffffff"]');
                    if (messageContainer) {
                        // Maintain consistent styling during streaming
                        messageContainer.style.wordWrap = 'break-word';
                        messageContainer.style.overflowWrap = 'break-word';
                        messageContainer.style.maxWidth = '100%';
                    }
                    
                    // Auto-scroll to show new content (throttled)
                    this.throttledScrollToBottom();
                } catch (error) {
                    console.error('Error updating message content:', error);
                    // Fallback: just set text content
                    contentDiv.textContent = content;
                }
            });
        } else {
            console.error(`Could not find content div for message ${messageId}`);
        }
    }
    
    updateMessageStatus(messageId, status) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            // Find the message-content div in the new structure
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv && status === 'failed') {
                contentDiv.innerHTML = '<div style="color:#ef4444;">Failed to process message. Please try again.</div>';
            }
        }
    }
    
    addVisualizationToMessage(messageId, visualizationData, toolResponses = []) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const container = messageDiv.querySelector('.visualizations-container');
            if (container) {
                const chartId = `chart-${messageId}-${Date.now()}`;
                const vizDiv = document.createElement('div');
                vizDiv.className = 'visualization mb-6 p-4 bg-gradient-to-r from-green-600 to-lime-400 rounded-lg ';
                vizDiv.innerHTML = `
                    <div class="flex items-center mb-3">
                        <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                        <h4 class="font-semibold text-white text-gray-800"> ${visualizationData.visualization_name || 'Data Visualization'}</h4>
                    </div>
                    <div class="chart-container bg-white p-4 rounded-lg shadow-sm">
                        <canvas id="${chartId}" width="400" height="200"></canvas>
                    </div>
                    <div class="mt-3   text-base  text-white text-gray-600">
                        <p>${visualizationData.frontend_data?.description || visualizationData.recommendation?.reasoning || 'Interactive chart based on your audio data'}</p>
                    </div>
                `;
                container.appendChild(vizDiv);
                
                // Create the chart with actual data
                setTimeout(() => {
                    this.createChart(visualizationData, chartId, toolResponses);
                }, 100);
            }
        }
    }
    
    createChart(visualizationData, canvasId, toolResponses = []) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        try {
            const frontendData = visualizationData.frontend_data;
            const chartType = frontendData.type;
            
            // Extract actual data from the tool responses
            const actualData = this.extractChartData(visualizationData, toolResponses);
            
            console.log('Creating chart:', chartType, 'with data:', actualData);
            
            // Create chart configuration based on type
            let config;
            
            switch (chartType) {
                case 'pie_chart':
                    config = {
                        type: 'pie',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                data: actualData.data,
                                backgroundColor: Array.isArray(actualData.colors) ? actualData.colors : this.generateColors(actualData.labels.length),
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' },
                                    padding: { bottom: 20 }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'bar_chart':
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: Array.isArray(actualData.colors) ? actualData.colors : this.generateColors(actualData.labels.length),
                                borderColor: Array.isArray(actualData.colors) ? actualData.colors : this.generateColors(actualData.labels.length),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'line_chart':
                    config = {
                        type: 'line',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Trend',
                                data: actualData.data,
                                borderColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                backgroundColor: (Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB') + '20',
                                tension: 0.4,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'box_plot':
                    // Use proper box plot with chartjs-chart-boxplot plugin
                    if (actualData.boxPlotData && actualData.boxPlotData.length > 0) {
                        config = {
                            type: 'boxplot',
                            data: {
                                labels: actualData.labels,
                                datasets: [{
                                    label: 'Decibel Distribution',
                                    data: actualData.boxPlotData,
                                    backgroundColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                    borderColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                    borderWidth: 2
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: { 
                                        title: {
                                            display: true,
                                            text: 'Decibel Level (dB)'
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { display: true },
                                    title: {
                                        display: true,
                                        text: actualData.title,
                                        font: { size: 16, weight: 'bold' }
                                    }
                                }
                            }
                        };
                    } else {
                        // Fallback to bar chart if box plot data not available
                        config = {
                            type: 'bar',
                            data: {
                                labels: actualData.labels,
                                datasets: [{
                                    label: 'Average dB',
                                    data: actualData.data,
                                    backgroundColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                    borderColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                    borderWidth: 1
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                scales: {
                                    y: { 
                                        beginAtZero: true,
                                        title: {
                                            display: true,
                                            text: 'Decibel Level (dB)'
                                        }
                                    }
                                },
                                plugins: {
                                    legend: { display: true },
                                    title: {
                                        display: true,
                                        text: actualData.title,
                                        font: { size: 16, weight: 'bold' }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            afterBody: function(context) {
                                                if (actualData.distributionInfo) {
                                                    const category = context[0].label;
                                                    const info = actualData.distributionInfo[category];
                                                    if (info) {
                                                        return [
                                                            `Count: ${info.count}`,
                                                            `Min: ${info.min?.toFixed(1)} dB`,
                                                            `Max: ${info.max?.toFixed(1)} dB`,
                                                            `Avg: ${info.avg?.toFixed(1)} dB`
                                                        ];
                                                    }
                                                }
                                                return [];
                                            }
                                        }
                                    }
                                }
                            }
                        };
                    }
                    break;
                    
                case 'scatter_plot':
                    config = {
                        type: 'scatter',
                        data: {
                            datasets: [{
                                label: 'Audio Data Points',
                                data: actualData.scatterData || [],
                                backgroundColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                borderColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { 
                                    type: 'linear',
                                    title: {
                                        display: true,
                                        text: actualData.xLabel || 'X Axis'
                                    }
                                },
                                y: { 
                                    title: {
                                        display: true,
                                        text: actualData.yLabel || 'Y Axis'
                                    }
                                }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'area_chart':
                    config = {
                        type: 'line',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Cumulative Value',
                                data: actualData.data,
                                borderColor: Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB',
                                backgroundColor: (Array.isArray(actualData.colors) ? actualData.colors[0] : '#36A2EB') + '40',
                                tension: 0.4,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                case 'heatmap':
                    // Chart.js doesn't have native heatmap, use a matrix-style bar chart
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Correlation Intensity',
                                data: actualData.data,
                                backgroundColor: Array.isArray(actualData.colors) ? actualData.colors : this.generateColors(actualData.labels.length),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;
                    
                default:
                    // Default to bar chart
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: Array.isArray(actualData.colors) ? actualData.colors : this.generateColors(actualData.labels.length),
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
            }
            
            // Create the chart
            new Chart(canvas, config);
            
            console.log('Chart created successfully:', canvasId);
        } catch (error) {
            console.error('Error creating chart:', error);
            // Show error message in the chart container
            const container = canvas.parentElement;
            container.innerHTML = '<div class="text-red-500 text-center p-4">Failed to load chart</div>';
        }
    }
    
    extractChartData(visualizationData, toolResponses = []) {
        console.log('Extracting chart data from:', visualizationData, 'Tool responses:', toolResponses);
        
        // Try to extract actual data from tool responses
        let extractedData = null;
        
        for (const toolResponse of toolResponses) {
            // Handle statistical distribution data (for box plots)
            if (typeof toolResponse === 'object' && toolResponse.analysis_type === 'statistical_distribution') {
                try {
                    const distributionData = toolResponse.distribution_data;
                    if (distributionData) {
                        const labels = Object.keys(distributionData);
                        const data = labels.map(label => distributionData[label].avg);
                        
                        // Generate box plot data (min, q1, median, q3, max) for each category
                        const boxPlotData = labels.map(label => {
                            const values = distributionData[label].decibel_values || [];
                            if (values.length === 0) return null;
                            
                            // Sort values for quartile calculation
                            const sortedValues = [...values].sort((a, b) => a - b);
                            const n = sortedValues.length;
                            
                            const min = sortedValues[0];
                            const max = sortedValues[n - 1];
                            const median = this.calculateMedian(sortedValues);
                            const q1 = this.calculateQuartile(sortedValues, 0.25);
                            const q3 = this.calculateQuartile(sortedValues, 0.75);
                            
                            return [min, q1, median, q3, max];
                        }).filter(data => data !== null);
                        
                        extractedData = {
                            labels: labels,
                            data: data,
                            boxPlotData: boxPlotData,
                            colors: this.generateColors(labels.length),
                            title: 'Distribution of Decibel Levels Across Categories',
                            distributionInfo: distributionData  // For tooltips
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error parsing statistical distribution:', e);
                }
            }
            // Handle array responses (like region counts)
            else if (Array.isArray(toolResponse)) {
                try {
                    if (toolResponse.length > 0 && toolResponse[0].region_name) {
                        // Extract region data from array format
                        const labels = toolResponse.map(item => item.region_name);
                        const data = toolResponse.map(item => item.noise_dataset_count);
                        
                        extractedData = {
                            labels: labels,
                            data: data,
                            colors: this.generateColors(labels.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error parsing array response:', e);
                }
            }
            // Handle object responses with datasets
            else if (typeof toolResponse === 'object' && toolResponse.datasets) {
                try {
                    const datasets = toolResponse.datasets;
                    if (Array.isArray(datasets)) {
                        const regions = datasets.map(d => d.region);
                        const uniqueRegions = [...new Set(regions)];
                        const counts = uniqueRegions.map(region => 
                            regions.filter(r => r === region).length
                        );
                        
                        extractedData = {
                            labels: uniqueRegions,
                            data: counts,
                            colors: this.generateColors(uniqueRegions.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error processing dataset response:', e);
                }
            }
            // Handle analysis results with different types
            else if (typeof toolResponse === 'object' && toolResponse.analysis_type) {
                try {
                    if (toolResponse.analysis_type === 'energy_analysis' && toolResponse.results) {
                        const results = toolResponse.results;
                        if (Array.isArray(results) && results.length > 0) {
                            const labels = results.map(r => r.region__name || r.category__name || 'Overall');
                            const data = results.map(r => r.avg_decibel || r.avg_rms_energy || 0);
                            
                            extractedData = {
                                labels: labels,
                                data: data,
                                colors: this.generateColors(labels.length),
                                title: 'Energy Analysis Results'
                            };
                            break;
                        }
                    } else if (toolResponse.analysis_type === 'spectral_analysis' && toolResponse.results) {
                        const results = toolResponse.results;
                        if (Array.isArray(results) && results.length > 0) {
                            const labels = results.map(r => r.region__name || r.category__name || 'Overall');
                            const data = results.map(r => r.avg_spectral_centroid || 0);
                            
                            extractedData = {
                                labels: labels,
                                data: data,
                                colors: this.generateColors(labels.length),
                                title: 'Spectral Analysis Results'
                            };
                            break;
                        }
                    } else if (toolResponse.analysis_type === 'temporal_analysis' && toolResponse.monthly_trends) {
                        const trends = toolResponse.monthly_trends;
                        if (Array.isArray(trends) && trends.length > 0) {
                            const labels = trends.map(t => t.month);
                            const data = trends.map(t => t.count);
                            
                            extractedData = {
                                labels: labels,
                                data: data,
                                colors: this.generateColors(1),
                                title: 'Audio Recording Trends Over Time'
                            };
                            break;
                        }
                    } else if (toolResponse.analysis_type === 'correlation_analysis' && toolResponse.correlation_data) {
                        const correlationData = toolResponse.correlation_data;
                        if (Array.isArray(correlationData) && correlationData.length > 0) {
                            const scatterData = correlationData.map(item => ({
                                x: item.x_value || item.rms_energy || 0,
                                y: item.y_value || item.spectral_centroid || 0
                            }));
                            
                            extractedData = {
                                scatterData: scatterData,
                                colors: this.generateColors(1),
                                title: 'Correlation Analysis',
                                xLabel: 'RMS Energy',
                                yLabel: 'Spectral Centroid'
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.log('Error processing analysis response:', e);
                }
            }
            // Handle string responses
            else if (typeof toolResponse === 'string') {
                try {
                    // Parse string responses that might contain data
                    if (toolResponse.includes('datasets') && toolResponse.includes('region')) {
                        // Extract region data from the tool response
                        const match = toolResponse.match(/'region':\s*'([^']+)'/g);
                        if (match) {
                            const regions = match.map(m => m.match(/'region':\s*'([^']+)'/)[1]);
                            const uniqueRegions = [...new Set(regions)];
                            const counts = uniqueRegions.map(region => 
                                regions.filter(r => r === region).length
                            );
                            
                            extractedData = {
                                labels: uniqueRegions,
                                data: counts,
                                colors: this.generateColors(uniqueRegions.length),
                                title: 'Distribution of Audio Files by Region'
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.log('Error parsing tool response:', e);
                }
            }
        }
        
        // If we extracted data, return it
        if (extractedData) {
            return extractedData;
        }
        
        // Check if there's a chart_template in the recommendation with actual data
        const recommendation = visualizationData.recommendation;
        if (recommendation && recommendation.chart_template) {
            const template = recommendation.chart_template;
            if (template.data && template.data.labels && template.data.values) {
                return {
                    labels: template.data.labels,
                    data: template.data.values,
                    colors: template.data.colors || this.generateColors(template.data.labels.length),
                    title: template.layout?.title || 'Audio Data Distribution'
                };
            }
        }
        
        // Fallback: Use the data from the sample response (Ashanti region with 2 files)
        return {
            labels: ['Ashanti'],
            data: [2],
            colors: ['#FF6384'],
            title: 'Distribution of Audio Files by Region'
        };
    }
    
    generateColors(count) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
            '#4BC0C0', '#FF6384', '#36A2EB', '#FFCE56'
        ];
        return colors.slice(0, count);
    }
    
    calculateMedian(sortedArray) {
        const n = sortedArray.length;
        if (n % 2 === 0) {
            return (sortedArray[n / 2 - 1] + sortedArray[n / 2]) / 2;
        } else {
            return sortedArray[Math.floor(n / 2)];
        }
    }
    
    calculateQuartile(sortedArray, percentile) {
        const n = sortedArray.length;
        const index = percentile * (n - 1);
        const lower = Math.floor(index);
        const upper = Math.ceil(index);
        const weight = index % 1;
        
        if (upper >= n) return sortedArray[n - 1];
        return sortedArray[lower] * (1 - weight) + sortedArray[upper] * weight;
    }
    
    async deleteSession(sessionId) {
        if (!confirm('Are you sure you want to delete this session?')) return;
        
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/archive/`, {
                method: 'POST',
                headers: this.headers
            });
            
            if (response.ok) {
                this.sessions = this.sessions.filter(s => s.id !== sessionId);
                if (this.currentSession?.id === sessionId) {
                    this.currentSession = null;
                    this.showWelcomeScreen();
                }
                this.updateSessionsList();
                this.showSuccessToast('Session deleted successfully');
            }
        } catch (error) {
            console.error('Error deleting session:', error);
            this.showErrorToast('Failed to delete session');
        }
    }
    
    showWelcomeScreen() {
        document.getElementById('welcomeScreen').classList.remove('hidden');
        document.getElementById('chatContainer').classList.add('hidden');
        document.getElementById('chatInputContainer').classList.add('hidden');
        document.getElementById('messagesContainer').innerHTML = '';
        this.updateChatTitle('Welcome to Data Insights!');
    }
    
    showChatInterface() {
        document.getElementById('welcomeScreen').classList.add('hidden');
        document.getElementById('chatContainer').classList.remove('hidden');
        document.getElementById('chatInputContainer').classList.remove('hidden');
    }
    
    updateChatTitle(title) {
        document.getElementById('chatTitle').textContent = title;
    }
    
    scrollToBottom() {
        const container = document.getElementById('chatContainer');
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    }
    
    throttledScrollToBottom() {
        // Throttle scrolling for better performance during rapid streaming
        if (this.scrollThrottle) {
            clearTimeout(this.scrollThrottle);
        }
        
        this.scrollThrottle = setTimeout(() => {
            this.scrollToBottom();
        }, 16); // ~60fps
    }
    
    showToolActivity(messageId) {
        // Show a subtle indicator that AI tools are working
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            let indicator = messageDiv.querySelector('.tool-activity-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.className = 'tool-activity-indicator';
                indicator.innerHTML = '<div style="font-size:0.75rem; color:#6b7280; margin-top:0.25rem;"><span>ðŸ”§</span> Analyzing data...</div>';
                
                const contentContainer = messageDiv.querySelector('.message-content');
                if (contentContainer && contentContainer.parentNode) {
                    contentContainer.parentNode.appendChild(indicator);
                }
            }
        }
    }
    
    hideToolActivity(messageId) {
        // Hide the tool activity indicator
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const indicator = messageDiv.querySelector('.tool-activity-indicator');
            if (indicator) {
                indicator.remove();
            }
        }
    }
    
    setSendButtonLoading(loading) {
        const btn = document.getElementById('sendBtn');
        if (loading) {
            btn.disabled = true;
            btn.innerHTML = '<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>';
        } else {
            btn.disabled = false;
            btn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        }
    }
    
    showLoading() {
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }
    
    hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }
    
    showErrorToast(message) {
        const toast = document.getElementById('errorToast');
        const messageEl = document.getElementById('errorMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');
        
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 5000);
    }
    
    showSuccessToast(message) {
        const toast = document.getElementById('successToast');
        const messageEl = document.getElementById('successMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');
        
        setTimeout(() => {
            toast.classList.add('hidden');
        }, 3000);
    }
    
    formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 1) return 'Today';
        if (diffDays === 2) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays - 1} days ago`;
        
        return date.toLocaleDateString();
    }
    
    formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: true 
        });
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    formatMarkdown(text) {
        // Fast markdown formatting optimized for streaming
        if (!text || typeof text !== 'string') {
            return '';
        }
        
        // Cache for performance during streaming
        if (this._markdownCache && this._markdownCache.input === text) {
            return this._markdownCache.output;
        }
        
        let formattedText = text;
        
        try {
            // Remove chart configuration JSON blocks (they're handled by visualizations)
            formattedText = formattedText.replace(/```json\s*\{\s*"recommended_chart"[\s\S]*?```/g, '');
            formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"(pie|bar|line)"[\s\S]*?```/g, '');
            
            // Remove chart reasoning sections
            formattedText = formattedText.replace(/### Recommended Visualization:[\s\S]*?(?=###|$)/g, '');
            formattedText = formattedText.replace(/#### [^:]*Chart Configuration:[\s\S]*?(?=###|####|$)/g, '');
            
            // Process tables first (before other formatting)
            formattedText = this.formatTables(formattedText);
            
            // Also handle simple data tables (key: value pairs)
            formattedText = this.formatDataTables(formattedText);
            
            // Fast replacements for common markdown patterns
            const replacements = [
                // Code blocks
                [/```(\w+)?\n([\s\S]*?)```/g, '<pre class="bg-gray-100 p-4 rounded-lg overflow-x-auto"><code class="language-$1">$2</code></pre>'],
                // Inline code
                [/`([^`]+)`/g, '<code class="bg-gray-100 px-2 py-1 rounded text-sm font-mono">$1</code>'],
                // Headers (most common first)
                [/^###\s+(.+)$/gm, '<h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">$1</h3>'],
                [/^##\s+(.+)$/gm, '<h2 class="text-2xl font-bold mt-8 mb-4 text-gray-800">$1</h2>'],
                [/^####\s+(.+)$/gm, '<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-800">$1</h4>'],
                [/^#\s+(.+)$/gm, '<h1 class="text-3xl font-bold mt-8 mb-4 text-gray-800">$1</h1>'],
                // Bold/italic
                [/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>'],
                [/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>'],
                // Lists - improved handling
                [/^-\s+(.+)$/gm, '<li class="ml-4 mb-1 list-disc">$1</li>'],
                [/^\*\s+(.+)$/gm, '<li class="ml-4 mb-1 list-disc">$1</li>'],
                [/^\d+\.\s+(.+)$/gm, '<li class="ml-4 mb-1 list-decimal">$1</li>'],
                // Blockquotes
                [/^>\s+(.+)$/gm, '<blockquote class="border-l-4 border-gray-300 pl-4 py-2 my-4 bg-gray-50 italic text-gray-700">$1</blockquote>'],
                // Horizontal rules
                [/^---$/gm, '<hr class="my-6 border-gray-300">'],
                // Line breaks
                [/\n\n/g, '</p><p class="mb-4">'],
                [/\n/g, '<br>']
            ];
            
            // Apply replacements efficiently
            for (const [pattern, replacement] of replacements) {
                formattedText = formattedText.replace(pattern, replacement);
            }
            
            // Wrap orphaned list items in proper ul/ol tags
            formattedText = this.wrapListItems(formattedText);
            
            // Wrap in paragraphs and cleanup
            if (!formattedText.includes('<h') && !formattedText.includes('<pre') && !formattedText.includes('<table')) {
                formattedText = `<p class="mb-4">${formattedText}</p>`;
            }
            
            // Clean up empty tags and fix nested structures
            formattedText = formattedText
                .replace(/<p class="mb-4"><\/p>/g, '')
                .replace(/<p class="mb-4">(<h[1-6][^>]*>.*?<\/h[1-6]>)<\/p>/g, '$1')
                .replace(/<p class="mb-4">(<pre[^>]*>.*?<\/pre>)<\/p>/g, '$1')
                .replace(/<p class="mb-4">(<div[^>]*>.*?<\/div>)<\/p>/g, '$1')
                .replace(/<p class="mb-4">(<table[^>]*>.*?<\/table>)<\/p>/g, '$1');
            
        } catch (error) {
            console.warn('Markdown formatting error:', error);
            // Fallback: just escape HTML and preserve line breaks
            formattedText = text.replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
        }
        
        // Cache the result for repeated calls during streaming
        this._markdownCache = { input: text, output: formattedText };
        
        return formattedText;
    }
    
    formatTables(text) {
        // Enhanced table formatting for data analysis results
        try {
            // Match markdown tables (| header | header |)
            const tableRegex = /^\|(.+)\|\s*\n\|[-:\s|]+\|\s*\n((?:\|.+\|\s*\n?)*)/gm;
            
            return text.replace(tableRegex, (match, headerRow, bodyRows) => {
                try {
                    // Parse header
                    const headers = headerRow.split('|')
                        .map(h => h.trim())
                        .filter(h => h.length > 0);
                    
                    // Parse body rows
                    const rows = bodyRows.split('\n')
                        .filter(row => row.trim().length > 0)
                        .map(row => {
                            return row.split('|')
                                .map(cell => cell.trim())
                                .filter(cell => cell.length > 0);
                        })
                        .filter(row => row.length > 0);
                    
                    // Generate HTML table
                    let tableHTML = `
                        <div class="table-container my-4 overflow-x-auto">
                            <table class="min-w-full bg-white border border-gray-200 rounded-lg shadow-sm">
                                <thead class="bg-gray-50">
                                    <tr>
                    `;
                    
                    // Add headers
                    headers.forEach(header => {
                        tableHTML += `<th class="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200">${this.escapeHtml(header)}</th>`;
                    });
                    
                    tableHTML += `
                                    </tr>
                                </thead>
                                <tbody class="divide-y divide-gray-200">
                    `;
                    
                    // Add rows
                    rows.forEach((row, index) => {
                        const rowClass = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
                        tableHTML += `<tr class="${rowClass}">`;
                        
                        row.forEach((cell, cellIndex) => {
                            if (cellIndex < headers.length) {
                                // Check if cell contains numbers for right alignment
                                const isNumeric = /^[\d.,\s%$-]+$/.test(cell.trim());
                                const alignClass = isNumeric ? 'text-right' : 'text-left';
                                
                                tableHTML += `<td class="px-4 py-3 text-sm text-gray-900 ${alignClass} border-b border-gray-100">${this.escapeHtml(cell)}</td>`;
                            }
                        });
                        
                        tableHTML += `</tr>`;
                    });
                    
                    tableHTML += `
                                </tbody>
                            </table>
                        </div>
                    `;
                    
                    return tableHTML;
                    
                } catch (tableError) {
                    console.warn('Error formatting table:', tableError);
                    // Fallback: return original text
                    return match;
                }
            });
            
        } catch (error) {
            console.warn('Error in table formatting:', error);
            return text;
        }
    }
    
    formatDataTables(text) {
        // Format simple data tables from AI analysis results
        try {
            // Pattern for data analysis results (Region: Value, Category: Value, etc.)
            const dataListPattern = /^([A-Za-z\s]+):\s*(.+)$/gm;
            let matches = [];
            let match;
            
            // Collect consecutive data lines
            while ((match = dataListPattern.exec(text)) !== null) {
                matches.push({
                    key: match[1].trim(),
                    value: match[2].trim(),
                    fullMatch: match[0],
                    index: match.index
                });
            }
            
            // Group consecutive matches into tables
            if (matches.length >= 3) {
                let tableGroups = [];
                let currentGroup = [matches[0]];
                
                for (let i = 1; i < matches.length; i++) {
                    const prevMatch = matches[i - 1];
                    const currentMatch = matches[i];
                    
                    // Check if matches are consecutive (within 50 characters)
                    if (currentMatch.index - (prevMatch.index + prevMatch.fullMatch.length) < 50) {
                        currentGroup.push(currentMatch);
                    } else {
                        if (currentGroup.length >= 3) {
                            tableGroups.push(currentGroup);
                        }
                        currentGroup = [currentMatch];
                    }
                }
                
                if (currentGroup.length >= 3) {
                    tableGroups.push(currentGroup);
                }
                
                // Replace groups with formatted tables
                tableGroups.forEach(group => {
                    const tableHTML = this.createDataTable(group);
                    const firstMatch = group[0];
                    const lastMatch = group[group.length - 1];
                    
                    // Replace the entire group with the table
                    const groupText = text.substring(
                        firstMatch.index,
                        lastMatch.index + lastMatch.fullMatch.length
                    );
                    
                    text = text.replace(groupText, tableHTML);
                });
            }
            
            return text;
            
        } catch (error) {
            console.warn('Error formatting data tables:', error);
            return text;
        }
    }
    
    createDataTable(dataGroup) {
        // Create a nice table from data group
        let tableHTML = `
            <div class="data-table-container my-4">
                <div class="bg-white border border-gray-200 rounded-lg overflow-hidden shadow-sm">
                    <table class="w-full">
                        <tbody>
        `;
        
        dataGroup.forEach((item, index) => {
            const rowClass = index % 2 === 0 ? 'bg-white' : 'bg-gray-50';
            const isNumeric = /^[\d.,\s%$-]+$/.test(item.value);
            const valueClass = isNumeric ? 'text-right font-mono' : 'text-left';
            
            tableHTML += `
                <tr class="${rowClass}">
                    <td class="px-4 py-3 text-sm font-medium text-gray-700 w-1/2">${this.escapeHtml(item.key)}</td>
                    <td class="px-4 py-3 text-sm text-gray-900 ${valueClass}">${this.escapeHtml(item.value)}</td>
                </tr>
            `;
        });
        
        tableHTML += `
                        </tbody>
                    </table>
                </div>
            </div>
        `;
        
        return tableHTML;
    }
    
    wrapListItems(text) {
        // Wrap orphaned list items in proper ul/ol containers
        try {
            // Find sequences of list items
            const listItemRegex = /<li class="[^"]*list-disc[^"]*"[^>]*>.*?<\/li>/g;
            const numberedListRegex = /<li class="[^"]*list-decimal[^"]*"[^>]*>.*?<\/li>/g;
            
            // Wrap bullet lists
            text = text.replace(
                /(<li class="[^"]*list-disc[^"]*"[^>]*>.*?<\/li>(?:\s*<li class="[^"]*list-disc[^"]*"[^>]*>.*?<\/li>)*)/g,
                '<ul class="my-4">$1</ul>'
            );
            
            // Wrap numbered lists
            text = text.replace(
                /(<li class="[^"]*list-decimal[^"]*"[^>]*>.*?<\/li>(?:\s*<li class="[^"]*list-decimal[^"]*"[^>]*>.*?<\/li>)*)/g,
                '<ol class="my-4">$1</ol>'
            );
            
            return text;
            
        } catch (error) {
            console.warn('Error wrapping list items:', error);
            return text;
        }
    }
    
    getStreamingStats() {
        const stats = this.streamingStats;
        const avgUpdateTime = stats.updateTimes.length > 0 
            ? stats.updateTimes.reduce((a, b) => a + b, 0) / stats.updateTimes.length 
            : 0;
        
        return {
            messagesReceived: stats.messagesReceived,
            averageUpdateTime: avgUpdateTime.toFixed(2) + 'ms',
            lastUpdate: new Date(stats.lastUpdate).toLocaleTimeString(),
            totalUpdates: stats.updateTimes.length
        };
    }
    
    debugStreamingPerformance() {
        console.log('ðŸš€ Streaming Performance Stats:', this.getStreamingStats());
    }
    
    // Test function to verify all chart types work
    testAllChartTypes() {
        console.log('ðŸ§ª Testing all chart types...');
        
        const testData = {
            labels: ['Category A', 'Category B', 'Category C'],
            data: [10, 20, 15],
            colors: this.generateColors(3),
            title: 'Test Chart',
            scatterData: [
                {x: 1, y: 2}, {x: 2, y: 4}, {x: 3, y: 6}
            ],
            xLabel: 'X Axis',
            yLabel: 'Y Axis'
        };
        
        const chartTypes = ['pie_chart', 'bar_chart', 'line_chart', 'box_plot', 'scatter_plot', 'area_chart', 'heatmap'];
        
        chartTypes.forEach((chartType, index) => {
            try {
                // Create a test canvas
                const testCanvas = document.createElement('canvas');
                testCanvas.id = `test-chart-${index}`;
                testCanvas.width = 400;
                testCanvas.height = 200;
                
                // Test chart creation
                this.createChart({frontend_data: {type: chartType}}, `test-chart-${index}`, [testData]);
                console.log(`âœ… ${chartType} - Chart created successfully`);
                
                // Clean up
                testCanvas.remove();
            } catch (error) {
                console.error(`âŒ ${chartType} - Error:`, error);
            }
        });
        
        console.log('ðŸ§ª Chart type testing completed');
    }
}

// Global functions for suggestion handling
function startChatWithSuggestion(suggestion) {
    window.unifiedChat.createSessionAndSendMessage(suggestion);
}

// Debug function for streaming issues
function debugStreamingDOM() {
    const chat = window.unifiedChat;
    if (chat) {
        console.log('ðŸ” Streaming Debug Info:');
        console.log('Current session:', chat.currentSession);
        console.log('Is loading:', chat.isLoading);
        console.log('Performance stats:', chat.getStreamingStats());
        
        // Check DOM structure
        const messagesContainer = document.getElementById('messagesContainer');
        console.log('Messages container:', messagesContainer);
        console.log('Message count in DOM:', messagesContainer?.children.length || 0);
        
        // Check for message divs
        const messageDivs = document.querySelectorAll('[id^="message-"]');
        console.log('Message divs found:', messageDivs.length);
        
        messageDivs.forEach((div, index) => {
            const contentDiv = div.querySelector('.message-content');
            console.log(`Message ${index + 1}:`, {
                id: div.id,
                hasContentDiv: !!contentDiv,
                contentLength: contentDiv?.textContent?.length || 0
            });
        });
    }
}

// Add to global scope for debugging
window.debugStreamingDOM = debugStreamingDOM;
window.testAllCharts = () => window.unifiedChat.testAllChartTypes();

// Initialize the unified chat when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.unifiedChat = new UnifiedAudioDataChat();
    
    // Add global debugging
    window.debugStreaming = () => window.unifiedChat.debugStreamingPerformance();
    
    console.log('ðŸŽµ Unified Audio Data Chat initialized');
    console.log('ðŸ’¡ Debug commands available: debugStreamingDOM(), debugStreaming()');
});
</script>

<style>
/* Custom styles for the unified chat interface */
.message {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.session-item {
    transition: all 0.2s ease;
}

.session-item:hover {
    transform: translateX(2px);
}


.chart-container {
    position: relative;
    height: 300px;
    min-height: 250px;
}

.chart-container canvas {
    max-height: 300px;
}

/* Thinking animation */
.thinking-dots {
    display: inline-flex;
    gap: 2px;
}

.thinking-dots span {
    animation: thinking 1.4s ease-in-out infinite;
    color: #6b7280;
    font-weight: bold;
    font-size: 1.2em;
}

.thinking-dots span:nth-child(1) {
    animation-delay: 0s;
}

.thinking-dots span:nth-child(2) {
    animation-delay: 0.2s;
}

.thinking-dots span:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes thinking {
    0%, 60%, 100% {
        opacity: 0.3;
        transform: translateY(0);
    }
    30% {
        opacity: 1;
        transform: translateY(-4px);
    }
}

/* Message content styling for streaming - optimized for performance */
.message-content {
    word-wrap: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    white-space: pre-wrap;
    line-height: 1.6;
    /* GPU acceleration for smoother updates */
    transform: translateZ(0);
    will-change: contents;
    /* Optimize text rendering */
    text-rendering: optimizeSpeed;
}

/* Ensure messages don't break layout during streaming */
#messagesContainer {
    overflow-x: hidden;
    word-wrap: break-word;
}

#messagesContainer > div {
    max-width: 100%;
    overflow: hidden;
}

/* Enhanced table styling for data analysis */
.table-container {
    margin: 1.5rem 0;
    border-radius: 0.5rem;
    overflow: hidden;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.table-container table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
}

.table-container th {
    background-color: #f8fafc;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-size: 0.75rem;
    color: #374151;
    padding: 0.75rem 1rem;
    border-bottom: 2px solid #e5e7eb;
}

.table-container td {
    padding: 0.75rem 1rem;
    border-bottom: 1px solid #f3f4f6;
    vertical-align: top;
}

.table-container tr:hover {
    background-color: #f9fafb;
}

.table-container tr:last-child td {
    border-bottom: none;
}

/* Data table styling for AI analysis results */
.data-table-container {
    margin: 1rem 0;
}

.data-table-container table {
    font-size: 0.875rem;
}

.data-table-container td:first-child {
    font-weight: 500;
    background-color: #f8fafc;
    border-right: 1px solid #e5e7eb;
}

.data-table-container tr:hover {
    background-color: #f0f9ff;
}

/* Responsive table */
@media (max-width: 768px) {
    .table-container,
    .data-table-container {
        font-size: 0.75rem;
    }
    
    .table-container th,
    .table-container td,
    .data-table-container td {
        padding: 0.5rem;
    }
}

/* Enhanced markdown styling */
.message-content pre {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    overflow-x: auto;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
}

.message-content code {
    background-color: #f1f3f4;
    color: #d73a49;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
}

.message-content pre code {
    background-color: transparent;
    color: #24292e;
    padding: 0;
}

.message-content h1, 
.message-content h2, 
.message-content h3, 
.message-content h4 {
    color: #1f2937;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
}

.message-content h1 { font-size: 1.5rem; }
.message-content h2 { font-size: 1.25rem; }
.message-content h3 { font-size: 1.125rem; }
.message-content h4 { font-size: 1rem; }

.message-content ul, .message-content ol {
    margin: 1rem 0;
    padding-left: 1.5rem;
    list-style-position: inside;
}

.message-content ul {
    list-style-type: disc;
}

.message-content ol {
    list-style-type: decimal;
}

.message-content li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
    padding-left: 0.25rem;
}

.message-content li.list-disc {
    list-style-type: disc;
    margin-left: 1rem;
}

.message-content li.list-decimal {
    list-style-type: decimal;
    margin-left: 1rem;
}

/* Blockquote styling */
.message-content blockquote {
    border-left: 4px solid #e5e7eb;
    padding-left: 1rem;
    margin: 1rem 0;
    background-color: #f9fafb;
    padding: 1rem;
    border-radius: 0.25rem;
    font-style: italic;
    color: #6b7280;
}

.message-content p {
    line-height: 1.6;
    margin-bottom: 1rem;
}

.message-content strong {
    font-weight: 600;
    color: #111827;
}

.message-content em {
    font-style: italic;
    color: #4b5563;
}

/* Scrollbar styling */
#chatContainer::-webkit-scrollbar,
#sessionsList::-webkit-scrollbar {
    width: 6px;
}

#chatContainer::-webkit-scrollbar-track,
#sessionsList::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb,
#sessionsList::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb:hover,
#sessionsList::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>
{% endblock %}
