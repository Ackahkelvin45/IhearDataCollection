{% extends 'datacollection/layout.html' %}
{% load static %}
{% csrf_token %}

{% block content %}
<!-- CSRF Token -->
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

<div class="flex h-screen bg-gray-50">
    <!-- Sidebar -->
    <div class="w-80 bg-white border-r border-gray-200 flex flex-col">
        <!-- Header -->
        <div class="p-4 border-b border-gray-200">
            <div class="flex items-center justify-between mb-4">
                <h6 class="text-xl font-semibold text-gray-800">Chat Sessions</h6>
                <button id="newChatBtn" class="inline-flex items-center px-2 py-2  text-sm rounded-lg text-white bg-primary hover:opacity-90 shadow-sm text-sm">
                    <i class="fa-regular fa-plus mr-2"></i>
                    New Chat
                </button>
            </div>
        </div>

        <!-- Sessions List -->
        <div id="sessionsList" class="flex-1 overflow-y-auto p-4">
            <div class="text-center text-gray-500 py-8">
                <i class="fa-regular fa-message text-4xl mb-2"></i>
                <p>No sessions yet</p>
                <p class="text-sm">Start a new conversation</p>
            </div>
        </div>
    </div>

    <!-- Main Chat Area -->
    <div class="flex-1 flex flex-col">
        <!-- Chat Header -->
        <div class="bg-white border-b border-gray-200 p-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <a href="{% url 'insights:home' %}" class="text-gray-500 hover:text-primary transition-colors">
                        <i class="fa-solid fa-arrow-left"></i>
                    </a>
                    <div>
                        <h1 id="chatTitle" class="text-xl font-semibold text-gray-800">Welcome to Data Insights!</h1>
                        <p class="text-sm text-gray-500">Ask me anything about your audio data</p>
                    </div>
                </div>
                <div class="flex items-center space-x-2">
                    <span id="connectionStatus" class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <span class="w-2 h-2 bg-green-400 rounded-full mr-1"></span>
                        Connected
                    </span>
                </div>
            </div>
        </div>

        <!-- Welcome Screen -->
        <div id="welcomeScreen" class="flex-1 flex flex-col items-center justify-center p-8">
            <div class="text-center max-w-2xl">
                <div class="mb-6">
                    <i class="fa-solid fa-chart-line text-6xl text-primary mb-4"></i>
                    <h2 class="text-3xl font-bold text-gray-800 mb-2">Audio Data Insights</h2>
                    <p class="text-gray-600 mb-8">Ask me anything about your audio data or try one of the suggestions below.</p>
                </div>

                <!-- Suggestions -->
                <div id="suggestionsContainer" class="flex flex-wrap justify-center gap-3 mb-8">
                    <button class="suggestion-btn px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        Show me the distribution of audio files by category
                    </button>
                    <button class="suggestion-btn px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        Compare decibel levels across different devices
                    </button>
                    <button class="suggestion-btn px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        Analyze noise trends over time
                    </button>
                    <button class="suggestion-btn px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        Show me audio files by region
                    </button>
                    <button class="suggestion-btn px-4 py-2 rounded-full bg-primary-light text-primary hover:bg-primary-hover border border-primary/10 shadow-sm transition">
                        What are the most common audio categories?
                    </button>
                </div>

                <!-- Input Form -->
                <form id="welcomeForm" class="w-full max-w-lg mx-auto">
                    <div class="relative">
                        <input
                            id="welcomeInput"
                            type="text"
                            class="w-full bg-slate-50 border border-slate-200 rounded-full py-4 pl-4 pr-16 outline-none text-slate-700 focus:ring-2 focus:ring-secondary/30 focus:border-secondary"
                            placeholder="Type your question..."
                        />
                        <button
                            type="submit"
                            class="absolute right-2 top-1/2 -translate-y-1/2 w-12 h-12 rounded-full bg-secondary text-white flex items-center justify-center shadow hover:opacity-90"
                            aria-label="Send"
                        >
                            <i class="fa-solid fa-paper-plane"></i>
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Chat Messages -->
        <div id="chatContainer" class="flex-1 overflow-y-auto p-4 hidden">
            <div id="messagesContainer" class="max-w-4xl mx-auto space-y-4">
                <!-- Messages will be dynamically added here -->
            </div>
        </div>

        <!-- Chat Input -->
        <div id="chatInputContainer" class="bg-white border-t border-gray-200 p-4 hidden">
            <div class="max-w-4xl mx-auto">
                <form id="chatForm" class="relative">
                    <div class="flex items-end space-x-3">
                        <div class="flex-1">
                            <textarea
                                id="messageInput"
                                rows="1"
                                class="w-full bg-slate-50 border border-slate-200 rounded-lg py-3 px-4 outline-none text-slate-700 focus:ring-2 focus:ring-secondary/30 focus:border-secondary resize-none"
                                placeholder="Ask about your audio data..."
                                style="min-height: 48px; max-height: 120px;"
                            ></textarea>
                        </div>
                        <button
                            type="submit"
                            id="sendBtn"
                            class="w-12 h-12 rounded-lg bg-secondary text-white flex items-center justify-center shadow hover:opacity-90 disabled:opacity-50"
                            aria-label="Send"
                        >
                            <i class="fa-solid fa-paper-plane"></i>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-white rounded-lg p-6 flex items-center space-x-3">
        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
        <span class="text-gray-700">Processing your request...</span>
    </div>
</div>

<!-- Error Toast -->
<div id="errorToast" class="fixed top-4 right-4 bg-red-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-exclamation-triangle"></i>
        <span id="errorMessage"></span>
    </div>
</div>

<!-- Success Toast -->
<div id="successToast" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 hidden">
    <div class="flex items-center space-x-2">
        <i class="fa-solid fa-check"></i>
        <span id="successMessage"></span>
    </div>
</div>

<!-- Include Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
// Audio Data Chat Implementation
class AudioDataChat {
    constructor() {
        this.apiBaseUrl = window.location.origin;
        this.headers = {
            'Content-Type': 'application/json',
            'X-CSRFToken': this.getCSRFToken()
        };
        this.currentSession = null;
        this.sessions = [];
        this.isLoading = false;
        this.currentMode = sessionStorage.getItem('insightsMode') || 'analysis';

        this.initializeEventListeners();
        this.updateModeUI();
        this.loadSessions();
    }

    getCSRFToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value ||
               document.querySelector('meta[name="csrf-token"]')?.content || '';
    }

    initializeEventListeners() {
        // New chat button
        document.getElementById('newChatBtn').addEventListener('click', () => {
            this.createNewSession();
        });

        // Welcome form submission
        document.getElementById('welcomeForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('welcomeInput');
            if (input.value.trim()) {
                this.createSessionAndSendMessage(input.value.trim());
            }
        });

        // Suggestion buttons
        document.querySelectorAll('.suggestion-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.createSessionAndSendMessage(btn.textContent.trim());
            });
        });

        // Chat form submission
        document.getElementById('chatForm').addEventListener('submit', (e) => {
            e.preventDefault();
            const input = document.getElementById('messageInput');
            if (input.value.trim() && this.currentSession) {
                this.sendMessage(input.value.trim());
                input.value = '';
                this.autoResizeTextarea(input);
            }
        });

        // Auto-resize textarea
        const messageInput = document.getElementById('messageInput');
        messageInput.addEventListener('input', () => {
            this.autoResizeTextarea(messageInput);
        });
    }

    autoResizeTextarea(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    async createNewSession() {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.hideWelcomeScreen();
            this.showChatInterface();
            this.showSuccessToast('New chat session created');
        } catch (error) {
            console.error('Error creating new session:', error);
            this.showErrorToast('Failed to create new session');
        } finally {
            this.hideLoading();
        }
    }

    async createSessionAndSendMessage(userInput) {
        try {
            this.showLoading();
            const session = await this.createSession();
            this.hideWelcomeScreen();
            this.showChatInterface();
            await this.sendMessage(userInput);
        } catch (error) {
            console.error('Error creating session and sending message:', error);
            this.showErrorToast('Failed to start conversation');
        } finally {
            this.hideLoading();
        }
    }

    async createSession() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                method: 'POST',
                headers: this.headers,
                body: JSON.stringify({ title: null, mode: this.currentMode })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to create session`);
            }

            const session = await response.json();
            this.currentSession = session;
            if (session.mode) {
                this.currentMode = session.mode;
                sessionStorage.setItem('insightsMode', session.mode);
            }
            this.sessions.unshift(session);
            this.updateSessionsList();
            this.updateChatTitle(session.title || 'New Chat');
            this.updateModeUI();

            return session;
        } catch (error) {
            console.error('Error creating session:', error);
            throw error;
        }
    }

    async loadSessions() {
        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/`, {
                headers: this.headers
            });

            if (response.ok) {
                const data = await response.json();
                // Handle paginated response - extract results array
                this.sessions = data.results || data;
                console.log('Loaded sessions:', this.sessions.length, 'sessions');
                this.updateSessionsList();
            } else if (response.status === 401) {
                // Handle authentication error
                this.showErrorToast('Please log in to access chat sessions');
                // Redirect to login or show login modal
                window.location.href = '/admin/login/';
            } else {
                console.error('Failed to load sessions:', response.status);
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
            this.showErrorToast('Failed to load chat sessions');
        }
    }

    updateSessionsList() {
        const container = document.getElementById('sessionsList');

        // Ensure sessions is an array
        if (!Array.isArray(this.sessions)) {
            this.sessions = [];
        }

        if (this.sessions.length === 0) {
            container.innerHTML = `
                <div class="text-center text-gray-500 py-8">
                    <i class="fa-regular fa-message text-4xl mb-2"></i>
                    <p>No sessions yet</p>
                    <p class="text-sm">Start a new conversation</p>
                </div>
            `;
            return;
        }

        container.innerHTML = this.sessions.map(session => `
            <div class="session-item p-3 rounded-lg cursor-pointer transition-colors mb-2 ${
                this.currentSession?.id === session.id ? 'bg-primary-light border border-primary/20' : 'hover:bg-gray-50'
            }" data-session-id="${session.id}">
                <div class="flex items-start justify-between">
                    <div class="flex-1 min-w-0">
                        <h3 class="font-medium text-gray-800 truncate">${session.title || 'Untitled Session'}</h3>
                        <p class="text-sm text-gray-500 mt-1">${session.total_messages} messages</p>
                        <p class="text-xs text-gray-400">${this.formatDate(session.updated_at)}</p>
                    </div>
                    <div class="flex items-center space-x-1 ml-2">
                        <button class="session-delete-btn p-1 text-gray-400 hover:text-red-500" data-session-id="${session.id}">
                            <i class="fa-regular fa-trash text-xs"></i>
                        </button>
                    </div>
                </div>
            </div>
        `).join('');

        // Add event listeners
        container.querySelectorAll('.session-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (!e.target.closest('.session-delete-btn')) {
                    const sessionId = parseInt(item.dataset.sessionId);
                    this.loadSession(sessionId);
                }
            });
        });

        container.querySelectorAll('.session-delete-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const sessionId = parseInt(btn.dataset.sessionId);
                this.deleteSession(sessionId);
            });
        });
    }

    async loadSession(sessionId) {
        try {
            this.showLoading();
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/`, {
                headers: this.headers
            });

            if (response.ok) {
                const session = await response.json();
                this.currentSession = session;
                if (session.mode) {
                    this.currentMode = session.mode;
                    sessionStorage.setItem('insightsMode', session.mode);
                }
                this.hideWelcomeScreen();
                this.showChatInterface();
                this.loadSessionMessages(session);
                this.updateSessionsList();
                this.updateChatTitle(session.title || 'Untitled Session');
                this.updateModeUI();
            } else {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || `HTTP ${response.status}: Failed to load session`);
            }
        } catch (error) {
            console.error('Error loading session:', error);
            this.showErrorToast('Failed to load session');
        } finally {
            this.hideLoading();
        }
    }

    updateModeUI() {
        const title = document.getElementById('chatTitle');
        const isMl = this.currentMode === 'ml';
        if (title) {
            title.textContent = isMl ? 'Machine Learning Insights' : 'Welcome to Data Insights!';
        }
        const input = document.getElementById('messageInput');
        if (input) {
            input.placeholder = isMl ? 'Ask ML questions about your data...' : 'Ask about your audio data...';
        }
    }

    loadSessionMessages(session) {
        const container = document.getElementById('messagesContainer');
        container.innerHTML = '';

        if (session.messages && session.messages.length > 0) {
            // Sort messages by creation date (oldest first)
            const sortedMessages = [...session.messages].sort((a, b) =>
                new Date(a.created_at) - new Date(b.created_at)
            );

            sortedMessages.forEach(message => {
                // Add user message
                this.addMessageToUI({
                    id: message.id,
                    user_input: message.user_input,
                    created_at: message.created_at,
                    status: message.status
                });

                // Add assistant message if it exists
                if (message.assistant_response && message.assistant_response.trim()) {
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response,
                        created_at: message.created_at,
                        status: message.status,
                        visulization: message.visulization
                    });

                    // Add visualization if it exists
                    if (message.visulization) {
                        setTimeout(() => {
                            this.addVisualizationToMessage(message.id + '_assistant', message.visulization);
                        }, 100);
                    }
                } else if (message.status === 'failed') {
                    // Show failed message
                    this.addMessageToUI({
                        id: message.id + '_assistant',
                        assistant_response: message.assistant_response || "This message failed to process. Please try again.",
                        created_at: message.created_at,
                        status: 'failed'
                    });
                }
            });
        }

        this.scrollToBottom();
    }

    async sendMessage(userInput) {
        if (!this.currentSession || this.isLoading) return;

        this.isLoading = true;
        this.setSendButtonLoading(true);

        // Add user message to UI
        const userMessage = {
            id: Date.now(),
            user_input: userInput,
            created_at: new Date().toISOString(),
            status: 'pending'
        };
        this.addMessageToUI(userMessage);

        // Add assistant message placeholder
        const assistantMessage = {
            id: Date.now() + 1,
            user_input: '',
            assistant_response: '',
            created_at: new Date().toISOString(),
            status: 'processing',
            visualizations: []
        };
        this.addMessageToUI(assistantMessage);

        try {
            const response = await fetch(
                `${this.apiBaseUrl}/insights/sessions/${this.currentSession.id}/messages/`,
                {
                    method: 'POST',
                    headers: this.headers,
                    body: JSON.stringify({
                        user_input: userInput,
                        ai_answer: true,
                        mode: this.currentMode
                    })
                }
            );

            if (!response.ok) {
                throw new Error('Failed to send message');
            }

            await this.handleStreamingResponse(response, assistantMessage);

        } catch (error) {
            console.error('Error sending message:', error);
            this.showErrorToast('Failed to send message');
            this.updateMessageStatus(assistantMessage.id, 'failed');
        } finally {
            this.isLoading = false;
            this.setSendButtonLoading(false);
        }
    }

    async handleStreamingResponse(response, assistantMessage) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        try {
            while (true) {
                const { done, value } = await reader.read();

                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (line.trim()) {
                        try {
                            const message = JSON.parse(line);
                            this.handleStreamMessage(message, assistantMessage);
                        } catch (e) {
                            console.warn('Failed to parse stream message:', line);
                        }
                    }
                }
            }
        } catch (error) {
            console.error('Streaming error:', error);
        }
    }

    handleStreamMessage(message, assistantMessage) {
        const { action, data } = message;

        switch (action) {
            case 'thinking':
                this.updateStreamStatus(assistantMessage.id, data?.message || 'Thinking...');
                break;

            case 'reasoning':
                this.updateStreamStatus(assistantMessage.id, data?.message || 'Reasoning...');
                break;

            case 'querying_db':
                if (data && data.tools && data.tools.length) {
                    this.updateStreamStatus(
                        assistantMessage.id,
                        `Querying database: ${data.tools.join(', ')}`
                    );
                } else {
                    this.updateStreamStatus(assistantMessage.id, data?.message || 'Querying database...');
                }
                break;

            case 'tool_call':
                if (data && data.tools && data.tools.length) {
                    this.updateStreamStatus(
                        assistantMessage.id,
                        `Querying database: ${data.tools.join(', ')}`
                    );
                } else {
                    this.updateStreamStatus(assistantMessage.id, 'Querying database...');
                }
                break;

            case 'tool_response':
                // Store tool responses for chart data extraction
                assistantMessage.toolResponses = assistantMessage.toolResponses || [];
                assistantMessage.toolResponses.push(data);
                this.updateStreamStatus(assistantMessage.id, 'Tool results received.');
                break;

            case 'llm':
                assistantMessage.assistant_response += data;
                this.updateMessageContent(assistantMessage.id, assistantMessage.assistant_response);
                break;

            case 'visualization':
                assistantMessage.visualizations = assistantMessage.visualizations || [];
                assistantMessage.visualizations.push(data);
                // Pass tool responses to extract actual data
                this.addVisualizationToMessage(assistantMessage.id, data, assistantMessage.toolResponses);
                break;

            case 'completed':
                this.updateStreamStatus(assistantMessage.id, 'Completed');
                this.updateMessageStatus(assistantMessage.id, 'completed');
                if (data && data.visualization) {
                    assistantMessage.visualizations = assistantMessage.visualizations || [];
                    assistantMessage.visualizations.push(data.visualization);
                    this.addVisualizationToMessage(
                        assistantMessage.id,
                        data.visualization,
                        assistantMessage.toolResponses
                    );
                }
                this.loadSessions(); // Refresh sessions list
                break;

            case 'error':
                console.error('Stream error:', data);
                this.updateMessageStatus(assistantMessage.id, 'failed');
                break;
        }
    }

    addMessageToUI(message) {
        const container = document.getElementById('messagesContainer');
        const messageDiv = document.createElement('div');
        messageDiv.id = `message-${message.id}`;
        messageDiv.className = 'message flex space-x-3';

        if (message.user_input && !message.assistant_response) {
            // User message
            messageDiv.innerHTML = `
                <div class="flex-shrink-0">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center">
                        <span class="text-white text-sm">ðŸ‘¤</span>
                    </div>
                </div>
                <div class="flex-1">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 shadow-sm">
                        <p class="text-gray-800 font-medium">${this.escapeHtml(message.user_input)}</p>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">${this.formatTime(message.created_at)}</p>
                </div>
            `;
        } else {
            // Assistant message
            messageDiv.innerHTML = `
                <div class="flex-shrink-0">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center">
                        <span class="text-white text-sm">ðŸ¤–</span>
                    </div>
                </div>
                <div class="flex-1">
                    <div class="bg-white border border-gray-200 rounded-lg p-4 shadow-sm">
                        <div class="message-content prose prose-sm max-w-none">
                            ${message.assistant_response ? this.formatMarkdown(message.assistant_response) :
                              '<div class="flex items-center space-x-2"><div class="animate-spin rounded-full h-4 w-4 border-b-2 border-primary"></div><span class="text-gray-500">Analyzing your audio data...</span></div>'}
                        </div>
                        <div class="stream-status text-xs text-gray-400 mt-2 hidden"></div>
                        <div class="visualizations-container mt-4"></div>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">${this.formatTime(message.created_at)}</p>
                </div>
            `;
        }

        container.appendChild(messageDiv);
        this.scrollToBottom();
    }

    updateMessageContent(messageId, content) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv) {
                contentDiv.innerHTML = this.formatMarkdown(content);
            }
        }
    }

    updateStreamStatus(messageId, text) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (!messageDiv) return;
        const statusDiv = messageDiv.querySelector('.stream-status');
        if (!statusDiv) return;
        statusDiv.textContent = text || '';
        if (text) {
            statusDiv.classList.remove('hidden');
        } else {
            statusDiv.classList.add('hidden');
        }
    }

    updateMessageStatus(messageId, status) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const contentDiv = messageDiv.querySelector('.message-content');
            if (contentDiv && status === 'failed') {
                contentDiv.innerHTML = '<div class="text-red-500">Failed to process message. Please try again.</div>';
            }
        }
    }

    addVisualizationToMessage(messageId, visualizationData, toolResponses = []) {
        const messageDiv = document.getElementById(`message-${messageId}`);
        if (messageDiv) {
            const container = messageDiv.querySelector('.visualizations-container');
            if (container) {
                if (container.dataset.rendered === 'true') {
                    return;
                }
                const chartId = `chart-${messageId}-${Date.now()}`;
                const tableData = visualizationData?.frontend_data?.table;
                const tableHtml = this.buildTableHtml(tableData);
                const hasTable = !!tableHtml;
                const vizDiv = document.createElement('div');
                vizDiv.className = 'visualization mb-6 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200';
                const layoutStyle = hasTable ? "display:flex; gap:12px; flex-wrap:wrap;" : "";
                const chartWrapStyle = hasTable ? "flex:1; min-width:260px;" : "";
                const tableWrapStyle = hasTable ? "flex:1; min-width:260px;" : "";
                vizDiv.innerHTML = `
                    <div class="flex items-center mb-3">
                        <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                        <h4 class="font-semibold text-gray-800">ðŸ“Š ${visualizationData.visualization_name || 'Data Visualization'}</h4>
                    </div>
                    <div style="${layoutStyle}">
                        <div style="${chartWrapStyle}">
                            <div class="chart-container bg-white p-4 rounded-lg shadow-sm">
                                <canvas id="${chartId}" width="400" height="200"></canvas>
                            </div>
                        </div>
                        ${hasTable ? `<div style="${tableWrapStyle}">${tableHtml}</div>` : ''}
                    </div>
                    <div class="mt-3 text-sm text-gray-600">
                        <p>${visualizationData.frontend_data?.description || visualizationData.recommendation?.reasoning || 'Interactive chart based on your audio data'}</p>
                    </div>
                `;
                container.appendChild(vizDiv);

                // Create the chart with actual data
                setTimeout(() => {
                    this.createChart(visualizationData, chartId, toolResponses);
                }, 100);
                container.dataset.rendered = 'true';
            }
        }
    }

    createChart(visualizationData, canvasId, toolResponses = []) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        try {
            const frontendData = visualizationData.frontend_data;
            const chartType = this.normalizeChartType(frontendData.type);

            // Extract actual data from the tool responses
            const actualData = this.extractChartData(visualizationData, toolResponses);

            console.log('Creating chart:', chartType, 'with data:', actualData);

            // Create chart configuration based on type
            let config;

            switch (chartType) {
                case 'pie_chart':
                    config = {
                        type: 'pie',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 2,
                                borderColor: '#ffffff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        padding: 20,
                                        usePointStyle: true
                                    }
                                },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' },
                                    padding: { bottom: 20 }
                                }
                            }
                        }
                    };
                    break;

                case 'bar_chart':
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors[0] || '#36A2EB',
                                borderColor: actualData.colors[0] || '#36A2EB',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                legend: { display: false },
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;

                case 'line_chart':
                    config = {
                        type: 'line',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Trend',
                                data: actualData.data,
                                borderColor: actualData.colors[0] || '#36A2EB',
                                backgroundColor: (actualData.colors[0] || '#36A2EB') + '20',
                                tension: 0.4,
                                fill: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            },
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
                    break;

                default:
                    // Default to bar chart
                    config = {
                        type: 'bar',
                        data: {
                            labels: actualData.labels,
                            datasets: [{
                                label: 'Count',
                                data: actualData.data,
                                backgroundColor: actualData.colors,
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                title: {
                                    display: true,
                                    text: actualData.title,
                                    font: { size: 16, weight: 'bold' }
                                }
                            }
                        }
                    };
            }

            // Create the chart
            new Chart(canvas, config);

            console.log('Chart created successfully:', canvasId);
        } catch (error) {
            console.error('Error creating chart:', error);
            // Show error message in the chart container
            const container = canvas.parentElement;
            container.innerHTML = '<div class="text-red-500 text-center p-4">Failed to load chart</div>';
        }
    }

    normalizeChartType(chartType) {
        if (!chartType) return 'bar_chart';
        const normalized = String(chartType).toLowerCase().replace(/[-_]/g, ' ').replace(/\s+/g, ' ').trim();
        const mapping = {
            'pie chart': 'pie_chart',
            'pie': 'pie_chart',
            'bar chart': 'bar_chart',
            'bar': 'bar_chart',
            'line chart': 'line_chart',
            'line': 'line_chart',
            'box plot': 'box_plot',
            'boxplot': 'box_plot',
            'scatter plot': 'scatter_plot',
            'scatter': 'scatter_plot',
            'area chart': 'area_chart',
            'area': 'area_chart',
            'heat map': 'heatmap',
            'heatmap': 'heatmap'
        };
        return mapping[normalized] || normalized.replace(' ', '_');
    }

    extractChartData(visualizationData, toolResponses = []) {
        console.log('Extracting chart data from:', visualizationData, 'Tool responses:', toolResponses);

        // Prefer explicit data shipped from backend
        if (visualizationData?.frontend_data?.labels && visualizationData?.frontend_data?.data) {
            return {
                labels: visualizationData.frontend_data.labels,
                data: visualizationData.frontend_data.data,
                colors: visualizationData.frontend_data.colors || this.generateColors(visualizationData.frontend_data.labels.length),
                title: visualizationData.frontend_data.title || visualizationData.frontend_data.name || 'Results'
            };
        }

        // Try to extract actual data from tool responses
        let extractedData = null;

        for (const toolResponse of toolResponses) {
            // Handle array responses (like region counts)
            if (Array.isArray(toolResponse)) {
                try {
                    if (toolResponse.length > 0 && typeof toolResponse[0] === 'object') {
                        const firstRow = toolResponse[0];
                        const keys = Object.keys(firstRow);
                        const numericKeys = keys.filter(k => toolResponse.some(r => typeof r?.[k] === 'number'));
                        const labelKeys = keys.filter(k => !numericKeys.includes(k));
                        if (numericKeys.length) {
                            const preferredNumeric = ['mean_db', 'max_db', 'min_db', 'avg', 'average', 'count', 'total', 'value', 'level', 'decibel'];
                            let valueKey = numericKeys[0];
                            preferredNumeric.forEach(pref => {
                                const match = numericKeys.find(k => k.toLowerCase().includes(pref));
                                if (match) valueKey = match;
                            });
                            const preferredLabels = ['name', 'dataset', 'noise_id', 'region', 'community', 'category', 'class', 'subclass', 'recording_device', 'device'];
                            let labelKey = labelKeys[0] || keys[0];
                            preferredLabels.forEach(pref => {
                                const match = labelKeys.find(k => k.toLowerCase().includes(pref));
                                if (match) labelKey = match;
                            });

                            const rows = toolResponse.slice(0, 12);
                            extractedData = {
                                labels: rows.map((r, idx) => String(r[labelKey] ?? `Row ${idx + 1}`)),
                                data: rows.map(r => Number(r[valueKey] ?? 0)),
                                colors: this.generateColors(rows.length),
                                title: visualizationData?.frontend_data?.title || 'Results'
                            };
                            break;
                        }
                    }
                    if (toolResponse.length > 0 && toolResponse[0].region_name) {
                        // Extract region data from array format
                        const labels = toolResponse.map(item => item.region_name);
                        const data = toolResponse.map(item => item.noise_dataset_count);

                        extractedData = {
                            labels: labels,
                            data: data,
                            colors: this.generateColors(labels.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error parsing array response:', e);
                }
            }
            // Handle object responses with datasets
            else if (typeof toolResponse === 'object' && toolResponse.datasets) {
                try {
                    const datasets = toolResponse.datasets;
                    if (Array.isArray(datasets)) {
                        const regions = datasets.map(d => d.region);
                        const uniqueRegions = [...new Set(regions)];
                        const counts = uniqueRegions.map(region =>
                            regions.filter(r => r === region).length
                        );

                        extractedData = {
                            labels: uniqueRegions,
                            data: counts,
                            colors: this.generateColors(uniqueRegions.length),
                            title: 'Distribution of Audio Files by Region'
                        };
                        break;
                    }
                } catch (e) {
                    console.log('Error processing dataset response:', e);
                }
            }
            // Handle string responses
            else if (typeof toolResponse === 'string') {
                try {
                    // Parse string responses that might contain data
                    if (toolResponse.includes('datasets') && toolResponse.includes('region')) {
                        // Extract region data from the tool response
                        const match = toolResponse.match(/'region':\s*'([^']+)'/g);
                        if (match) {
                            const regions = match.map(m => m.match(/'region':\s*'([^']+)'/)[1]);
                            const uniqueRegions = [...new Set(regions)];
                            const counts = uniqueRegions.map(region =>
                                regions.filter(r => r === region).length
                            );

                            extractedData = {
                                labels: uniqueRegions,
                                data: counts,
                                colors: this.generateColors(uniqueRegions.length),
                                title: 'Distribution of Audio Files by Region'
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.log('Error parsing tool response:', e);
                }
            }
        }

        // If we extracted data, return it
        if (extractedData) {
            return extractedData;
        }

        // Check if there's a chart_template in the recommendation with actual data
        const recommendation = visualizationData.recommendation;
        if (recommendation && recommendation.chart_template) {
            const template = recommendation.chart_template;
            if (template.data && template.data.labels && template.data.values) {
                return {
                    labels: template.data.labels,
                    data: template.data.values,
                    colors: template.data.colors || this.generateColors(template.data.labels.length),
                    title: template.layout?.title || 'Audio Data Distribution'
                };
            }
        }

        // Fallback: Use the data from the sample response (Ashanti region with 2 files)
        return {
            labels: ['Ashanti'],
            data: [2],
            colors: ['#FF6384'],
            title: 'Distribution of Audio Files by Region'
        };
    }

    generateColors(count) {
        const colors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
            '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF',
            '#4BC0C0', '#FF6384', '#36A2EB', '#FFCE56'
        ];
        return colors.slice(0, count);
    }

    buildTableHtml(tableData) {
        if (!tableData || !Array.isArray(tableData.columns) || !Array.isArray(tableData.rows) || tableData.rows.length === 0) {
            return '';
        }
        const columns = tableData.columns;
        const rows = tableData.rows;
        const header = columns.map(col => `<th style="text-align:left; padding:6px 8px; border-bottom:1px solid #e5e7eb; font-size:12px; color:#374151;">${this.escapeHtml(String(col))}</th>`).join('');
        const body = rows.map(row => {
            const cells = columns.map(col => `<td style="padding:6px 8px; border-bottom:1px solid #f3f4f6; font-size:12px; color:#111827;">${this.escapeHtml(String(row?.[col] ?? ''))}</td>`).join('');
            return `<tr>${cells}</tr>`;
        }).join('');
        return `
            <div style="background:#ffffff; border:1px solid #e5e7eb; border-radius:10px; overflow:hidden; box-shadow:0 1px 2px rgba(0,0,0,0.05);">
                <div style="padding:8px 10px; font-weight:600; font-size:12px; color:#374151; border-bottom:1px solid #e5e7eb;">Top Results</div>
                <div style="max-height:260px; overflow:auto;">
                    <table style="width:100%; border-collapse:collapse;">
                        <thead><tr>${header}</tr></thead>
                        <tbody>${body}</tbody>
                    </table>
                </div>
            </div>
        `;
    }

    generateSampleData(chartType) {
        // Generate sample data based on chart type
        switch (chartType) {
            case 'pie_chart':
                return {
                    labels: ['Urban Life and Public Spaces', 'Natural Soundscapes and Biodiversity'],
                    data: [1, 1]
                };
            case 'bar_chart':
                return {
                    labels: ['Urban Life', 'Natural Soundscapes', 'Commerce & Industry', 'Transport'],
                    data: [1, 1, 0, 0]
                };
            case 'line_chart':
                return {
                    labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                    data: [65, 59, 80, 81, 56, 55]
                };
            case 'heatmap':
                return {
                    labels: ['Urban', 'Natural', 'Commerce', 'Transport'],
                    data: [
                        [65, 59, 80, 81],
                        [56, 55, 40, 50],
                        [80, 81, 56, 55],
                        [40, 50, 65, 59]
                    ]
                };
            case 'scatter_plot':
                return {
                    labels: ['Point 1', 'Point 2', 'Point 3', 'Point 4'],
                    data: [
                        {x: 10, y: 20},
                        {x: 15, y: 10},
                        {x: 20, y: 30},
                        {x: 25, y: 15}
                    ]
                };
            case 'box_plot':
                return {
                    labels: ['Urban Life', 'Natural Soundscapes'],
                    data: [
                        [10, 20, 30, 40, 50],
                        [15, 25, 35, 45, 55]
                    ]
                };
            case 'area_chart':
                return {
                    labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
                    data: [65, 59, 80, 81, 56, 55]
                };
            default:
                return {
                    labels: ['Category 1', 'Category 2', 'Category 3'],
                    data: [10, 20, 30]
                };
        }
    }

    async deleteSession(sessionId) {
        if (!confirm('Are you sure you want to delete this session?')) return;

        try {
            const response = await fetch(`${this.apiBaseUrl}/insights/sessions/${sessionId}/archive/`, {
                method: 'POST',
                headers: this.headers
            });

            if (response.ok) {
                this.sessions = this.sessions.filter(s => s.id !== sessionId);
                if (this.currentSession?.id === sessionId) {
                    this.currentSession = null;
                    this.showWelcomeScreen();
                }
                this.updateSessionsList();
                this.showSuccessToast('Session deleted successfully');
            }
        } catch (error) {
            console.error('Error deleting session:', error);
            this.showErrorToast('Failed to delete session');
        }
    }

    hideWelcomeScreen() {
        document.getElementById('welcomeScreen').classList.add('hidden');
        document.getElementById('chatContainer').classList.remove('hidden');
        document.getElementById('chatInputContainer').classList.remove('hidden');
    }

    showWelcomeScreen() {
        document.getElementById('welcomeScreen').classList.remove('hidden');
        document.getElementById('chatContainer').classList.add('hidden');
        document.getElementById('chatInputContainer').classList.add('hidden');
        document.getElementById('messagesContainer').innerHTML = '';
    }

    showChatInterface() {
        this.hideWelcomeScreen();
    }

    updateChatTitle(title) {
        document.getElementById('chatTitle').textContent = title;
    }

    scrollToBottom() {
        const container = document.getElementById('chatContainer');
        container.scrollTop = container.scrollHeight;
    }

    setSendButtonLoading(loading) {
        const btn = document.getElementById('sendBtn');
        if (loading) {
            btn.disabled = true;
            btn.innerHTML = '<div class="animate-spin rounded-full h-4 w-4 border-b-2 border-white"></div>';
        } else {
            btn.disabled = false;
            btn.innerHTML = '<i class="fa-solid fa-paper-plane"></i>';
        }
    }

    showLoading() {
        document.getElementById('loadingOverlay').classList.remove('hidden');
    }

    hideLoading() {
        document.getElementById('loadingOverlay').classList.add('hidden');
    }

    showErrorToast(message) {
        const toast = document.getElementById('errorToast');
        const messageEl = document.getElementById('errorMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');

        setTimeout(() => {
            toast.classList.add('hidden');
        }, 5000);
    }

    showSuccessToast(message) {
        const toast = document.getElementById('successToast');
        const messageEl = document.getElementById('successMessage');
        messageEl.textContent = message;
        toast.classList.remove('hidden');

        setTimeout(() => {
            toast.classList.add('hidden');
        }, 3000);
    }

    formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffTime = Math.abs(now - date);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 1) return 'Today';
        if (diffDays === 2) return 'Yesterday';
        if (diffDays <= 7) return `${diffDays - 1} days ago`;

        return date.toLocaleDateString();
    }

    formatTime(dateString) {
        const date = new Date(dateString);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    formatMarkdown(text) {
        // Enhanced markdown formatting for better display
        let formattedText = text;

        // Remove chart configuration JSON blocks (they're handled by visualizations)
        formattedText = formattedText.replace(/```json\s*\{\s*"recommended_chart"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"pie"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"bar"[\s\S]*?```/g, '');
        formattedText = formattedText.replace(/```json\s*\{\s*"type":\s*"line"[\s\S]*?```/g, '');

        // Remove chart reasoning sections
        formattedText = formattedText.replace(/### Recommended Visualization:[\s\S]*?(?=###|$)/g, '');
        formattedText = formattedText.replace(/#### [^:]*Chart Configuration:[\s\S]*?(?=###|####|$)/g, '');
        formattedText = formattedText.replace(/Here's the template for creating[\s\S]*?```/g, '');

        return formattedText
            // Code blocks
            .replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre class="bg-gray-100 p-4 rounded-lg overflow-x-auto"><code class="language-$1">$2</code></pre>')
            // Inline code
            .replace(/`([^`]+)`/g, '<code class="bg-gray-100 px-2 py-1 rounded text-sm font-mono">$1</code>')
            // Headers
            .replace(/^####\s+(.+)$/gm, '<h4 class="text-lg font-semibold mt-4 mb-2 text-gray-800">$1</h4>')
            .replace(/^###\s+(.+)$/gm, '<h3 class="text-xl font-semibold mt-6 mb-3 text-gray-800">$1</h3>')
            .replace(/^##\s+(.+)$/gm, '<h2 class="text-2xl font-bold mt-8 mb-4 text-gray-800">$1</h2>')
            .replace(/^#\s+(.+)$/gm, '<h1 class="text-3xl font-bold mt-8 mb-4 text-gray-800">$1</h1>')
            // Bold text
            .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold text-gray-900">$1</strong>')
            // Italic text
            .replace(/\*(.*?)\*/g, '<em class="italic text-gray-700">$1</em>')
            // Lists
            .replace(/^-\s+(.+)$/gm, '<li class="ml-4 mb-1">â€¢ $1</li>')
            // Line breaks
            .replace(/\n\n/g, '</p><p class="mb-4">')
            .replace(/\n/g, '<br>')
            // Wrap in paragraphs
            .replace(/^(?!<[^>]+>)(.+)$/gm, '<p class="mb-4">$1</p>')
            // Clean up empty paragraphs
            .replace(/<p class="mb-4"><\/p>/g, '')
            // Clean up nested paragraphs
            .replace(/<p class="mb-4">(<h[1-6][^>]*>.*?<\/h[1-6]>)<\/p>/g, '$1')
            .replace(/<p class="mb-4">(<pre[^>]*>.*?<\/pre>)<\/p>/g, '$1')
            .replace(/<p class="mb-4">(<li[^>]*>.*?<\/li>)<\/p>/g, '$1')
            // Clean up extra whitespace
            .replace(/\s*<br>\s*<br>\s*/g, '<br>')
            .replace(/<p class="mb-4">\s*<\/p>/g, '');
    }
}

// Initialize the chat when the page loads
document.addEventListener('DOMContentLoaded', () => {
    window.audioDataChat = new AudioDataChat();

    // Check for session to load from home page
    const loadSessionId = sessionStorage.getItem('loadSessionId');
    if (loadSessionId) {
        // Clear the stored session ID
        sessionStorage.removeItem('loadSessionId');
        // Load the specific session
        window.audioDataChat.loadSession(parseInt(loadSessionId));
        return;
    }

    // Check for initial message from home page
    const initialMessage = sessionStorage.getItem('initialMessage');
    if (initialMessage) {
        // Clear the stored message
        sessionStorage.removeItem('initialMessage');
        // Create session and send the initial message
        window.audioDataChat.createSessionAndSendMessage(initialMessage);
    }
});
</script>

<style>
/* Custom styles for the chat interface */
.message {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.session-item {
    transition: all 0.2s ease;
}

.session-item:hover {
    transform: translateX(2px);
}

.visualization {
    border-left: 3px solid #3b82f6;
}

.chart-container {
    position: relative;
    height: 300px;
    min-height: 250px;
}

.chart-container canvas {
    max-height: 300px;
}

/* Enhanced markdown styling */
.message-content pre {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    overflow-x: auto;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
}

.message-content code {
    background-color: #f1f3f4;
    color: #d73a49;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
}

.message-content pre code {
    background-color: transparent;
    color: #24292e;
    padding: 0;
}

.message-content h1,
.message-content h2,
.message-content h3,
.message-content h4 {
    color: #1f2937;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
}

.message-content h1 { font-size: 1.5rem; }
.message-content h2 { font-size: 1.25rem; }
.message-content h3 { font-size: 1.125rem; }
.message-content h4 { font-size: 1rem; }

.message-content ul, .message-content ol {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.message-content li {
    margin-bottom: 0.5rem;
    line-height: 1.6;
}

.message-content p {
    line-height: 1.6;
    margin-bottom: 1rem;
}

.message-content strong {
    font-weight: 600;
    color: #111827;
}

.message-content em {
    font-style: italic;
    color: #4b5563;
}

/* Scrollbar styling */
#chatContainer::-webkit-scrollbar,
#sessionsList::-webkit-scrollbar {
    width: 6px;
}

#chatContainer::-webkit-scrollbar-track,
#sessionsList::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb,
#sessionsList::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 3px;
}

#chatContainer::-webkit-scrollbar-thumb:hover,
#sessionsList::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}
</style>
{% endblock %}
